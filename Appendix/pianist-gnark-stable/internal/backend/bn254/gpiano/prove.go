// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

// Modifications Copyright 2023 Tianyi Liu and Tiancheng Xie

package gpiano

import (
	"crypto/sha256"
	"fmt"
	"math/big"
	"math/bits"
	"runtime"
	"time"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr/dkzg"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr/fft"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr/kzg"
	"github.com/consensys/gnark-crypto/fiat-shamir"
	"github.com/consensys/gnark/backend"
	"github.com/consensys/gnark/internal/backend/bn254/cs"
	"github.com/consensys/gnark/internal/utils"
	"github.com/consensys/gnark/logger"
	"github.com/sunblaze-ucb/simpleMPI/mpi"

	curve "github.com/consensys/gnark-crypto/ecc/bn254"
	bn254witness "github.com/consensys/gnark/internal/backend/bn254/witness"
)

var (
	World *mpi.MPIWorld
)

// Proof denotes a Piano proof generated from M parties each with N rows.
type Proof struct {

	// Commitments to the solution vectors
	LRO [3]dkzg.Digest

	// Commitment to Z, W, the permutation polynomial
	Z dkzg.Digest
	W kzg.Digest

	// Commitments to Hx1, Hx2, Hx3 such that
	// Hx = Hx1 + (X**N) * Hx2 + (X**(2N)) * Hx3 and
	// commitments to Hy1, Hy2, Hy3 such that
	// Hy = Hy1 + (Y**M) * Hy2 + (Y**(2M)) * Hy3
	Hx [4]dkzg.Digest
	Hy [4]kzg.Digest

	// Batch partially opening proof of
	// foldedHx(Y, X) = Hx1(Y, X) + alpha*Hx2(Y, X) + (alpha**2)*Hx3(Y, X),
	// L(Y, X), R(Y, X), O(Y, X), Ql(Y, X), Qr(Y, X), Qm(Y, X), Qo(Y, X),
	// Qk(Y, X), Sy1(Y, X), Sy2(Y, X), Sy3(Y, X), Sx1(Y, X), Sx2(Y, X), Sx3(Y, X)
	// Z(Y, X) on X = alpha
	PartialBatchedProof dkzg.BatchOpeningProof

	// Opening partially proof of Z(Y, X) on X = omegaX * alpha
	PartialZShiftedProof dkzg.OpeningProof

	// Batch opening proof of FoldedHx(Y, alpha), L(Y, alpha), R(Y, alpha), O(Y, alpha),
	// Ql(Y, alpha), Qr(Y, alpha), Qm(Y, alpha), Qo(Y, alpha), Qk(Y, alpha),
	// Sy1(Y, alpha), Sy2(Y, alpha), Sy3(Y, alpha), Sx1(Y, alpha), Sx2(Y, alpha), Sx3(Y, alpha),
	// Z(Y, alpha), z(Y, omegaX * alpha), W(Y), FoldedHy(Y) on Y = beta
	BatchedProof kzg.BatchOpeningProof

	// Opening partially proof of W(Y) on Y = omegaY * beta
	WShiftedProof kzg.OpeningProof
}

// Prove from the public data
func Prove(spr *cs.SparseR1CS, pk *ProvingKey, fullWitness bn254witness.Witness, opt backend.ProverConfig) (*Proof, error) {
	// compute the constraint system solution
	var solution []fr.Element
	var err error
	if solution, err = spr.Solve(fullWitness, opt); err != nil {
		if !opt.Force {
			return nil, err
		} else {
			// we need to fill solution with random values
			var r fr.Element
			_, _ = r.SetRandom()
			for i := spr.NbPublicVariables + spr.NbSecretVariables; i < len(solution); i++ {
				solution[i] = r
				r.Double(&r)
			}
		}
	}

	fmt.Println("Solution computed")
	fmt.Println("Prover started")
	log := logger.Logger().With().Str("curve", spr.CurveID().String()).Int("nbConstraints", len(spr.Constraints)).Str("backend", "gpiano").Logger()
	start := time.Now()
	// pick a hash function that will be used to derive the challenges
	hFunc := sha256.New()

	// create a transcript manager to apply Fiat Shamir
	fs := fiatshamir.NewTranscript(hFunc, "gamma", "etaY", "etaX", "lambda", "alpha", "beta")

	// result
	proof := &Proof{}

	// query L, R, O in Lagrange basis, not blinded
	lSmallX, rSmallX, oSmallX := evaluateLROSmallDomainX(spr, pk, solution)

	// save lL, lR, lO, and make a copy of them in
	// canonical basis note that we allocate more capacity to reuse for blinded
	// polynomials
	lCanonicalX, rCanonicalX, oCanonicalX := computeLROCanonicalX(
		lSmallX,
		rSmallX,
		oSmallX,
		&pk.Domain[0],
	)
	if err != nil {
		return nil, err
	}

	// compute kzg commitments of bcL, bcR and bcO
	if err := commitToLRO(lCanonicalX, rCanonicalX, oCanonicalX, proof, pk.Vk.DKZGSRS); err != nil {
		return nil, err
	}

	// The first challenge is derived using the public data: the commitments to the permutation,
	// the coefficients of the circuit, and the public inputs.
	// derive gamma from the Comm(cL), Comm(cR), Comm(cO)
	if err := bindPublicData(&fs, "gamma", *pk.Vk, fullWitness[:spr.NbPublicVariables]); err != nil {
		return nil, err
	}
	gamma, err := deriveRandomness(&fs, "gamma", false, &proof.LRO[0], &proof.LRO[1], &proof.LRO[2])
	if err != nil {
		return nil, err
	}

	// Fiat Shamir this
	etaY, err := deriveRandomness(&fs, "etaY", false)
	if err != nil {
		return nil, err
	}

	// Fiat Shamir this
	etaX, err := deriveRandomness(&fs, "etaX", false)
	if err != nil {
		return nil, err
	}

	// compute Z, the permutation accumulator polynomial, in canonical basis
	// lL, lR, lO are NOT blinded
	
	zCanonicalX, selfProd, err := computeZCanonicalX(
		lSmallX,
		rSmallX,
		oSmallX,
		pk, etaY, etaX, gamma,
	)
	if err != nil {
		return nil, err
	}

	wSmallY, wCanonicalY, pW, cW, err := computeWCanonicalY(selfProd)
	if err != nil {
		return nil, err
	}

	// commit to z
	// note that we explicitly double the number of tasks for the multi exp
	// in dkzg.Commit
	// this may add additional arithmetic operations, but with smaller tasks
	// we ensure that this commitment is well parallelized, without having a
	// "unbalanced task" making the rest of the code wait too long
	if proof.Z, err = dkzg.Commit(zCanonicalX, pk.Vk.DKZGSRS, runtime.NumCPU()*2); err != nil {
		return nil, err
	}
	if mpi.SelfRank == 0 {
		if proof.W, err = kzg.Commit(wCanonicalY, globalSRS); err != nil {
			return nil, err
		}
	}

	// derive lambda from the Comm(L), Comm(R), Comm(O), Com(Z)
	lambda, err := deriveRandomness(&fs, "lambda", false, &proof.Z, &proof.W)
	if err != nil {
		return nil, err
	}

	hx1, hx2, hx3, hx4 := computeQuotientCanonicalX(pk, lCanonicalX, rCanonicalX, oCanonicalX, zCanonicalX, *pW, *cW, etaY, etaX, gamma, lambda)

	// print vector of hx1, hx2, hx3, hx4

	// compute kzg commitments of Hx1, Hx2, Hx3, Hx4
	if err := commitToQuotientX(hx1, hx2, hx3, hx4, proof, pk.Vk.DKZGSRS); err != nil {
		return nil, err
	}

	// derive alpha
	alpha, err := deriveRandomness(&fs, "alpha", false, &proof.Hx[0], &proof.Hx[1], &proof.Hx[2], &proof.Hx[3])
	if err != nil {
		return nil, err
	}

	// open Z at u*alpha
	var alphaShifted fr.Element
	alphaShifted.Mul(&alpha, &pk.Domain[0].Generator)
	var zShiftedAlpha []fr.Element
	proof.PartialZShiftedProof, zShiftedAlpha, err = dkzg.Open(
		zCanonicalX,
		alphaShifted,
		pk.Vk.DKZGSRS,
	)
	if err != nil {
		return nil, err
	}

	// foldedHDigest = Comm(Hx1) + (alpha**(N))*Comm(Hx2) + (alpha**(2(N)))*Comm(Hx3) + (alpha**(3(N)))*Comm(Hx4)
	var bAlphaPowerN, bSize big.Int
	bSize.SetUint64(pk.Domain[0].Cardinality)
	var alphaPowerN fr.Element
	alphaPowerN.Exp(alpha, &bSize)
	alphaPowerN.ToBigIntRegular(&bAlphaPowerN)
	foldedHxDigest := proof.Hx[3]
	foldedHxDigest.ScalarMultiplication(&foldedHxDigest, &bAlphaPowerN)
	foldedHxDigest.Add(&foldedHxDigest, &proof.Hx[2])
	foldedHxDigest.ScalarMultiplication(&foldedHxDigest, &bAlphaPowerN)
	foldedHxDigest.Add(&foldedHxDigest, &proof.Hx[1])                  
	foldedHxDigest.ScalarMultiplication(&foldedHxDigest, &bAlphaPowerN)
	foldedHxDigest.Add(&foldedHxDigest, &proof.Hx[0])                  

	// foldedHx = Hx1 + (alpha**(N))*Hx2 + (alpha**(2(N)))*Hx3
	foldedHx := hx4
	utils.Parallelize(len(foldedHx), func(start, end int) {
		for i := start; i < end; i++ {
			foldedHx[i].Mul(&foldedHx[i], &alphaPowerN)
			foldedHx[i].Add(&foldedHx[i], &hx3[i])
			foldedHx[i].Mul(&foldedHx[i], &alphaPowerN)
			foldedHx[i].Add(&foldedHx[i], &hx2[i])
			foldedHx[i].Mul(&foldedHx[i], &alphaPowerN)
			foldedHx[i].Add(&foldedHx[i], &hx1[i])
		}
	})

	dkzgOpeningPolys := [][]fr.Element{
		foldedHx,
		lCanonicalX,
		rCanonicalX,
		oCanonicalX,
		pk.Ql,
		pk.Qr,
		pk.Qm,
		pk.Qo,
		pk.Qk,
		pk.Sy1Canonical,
		pk.Sy2Canonical,
		pk.Sy3Canonical,
		pk.Sx1Canonical,
		pk.Sx2Canonical,
		pk.Sx3Canonical,
		zCanonicalX,
	}
	dkzgDigests := []dkzg.Digest{
		foldedHxDigest,
		proof.LRO[0],
		proof.LRO[1],
		proof.LRO[2],
		pk.Vk.Ql,
		pk.Vk.Qr,
		pk.Vk.Qm,
		pk.Vk.Qo,
		pk.Vk.Qk,
		pk.Vk.Sy[0],
		pk.Vk.Sy[1],
		pk.Vk.Sy[2],
		pk.Vk.Sx[0],
		pk.Vk.Sx[1],
		pk.Vk.Sx[2],
		proof.Z,
	}

	// Batch open the first list of polynomials
	var evalsXOnAlpha [][]fr.Element
	proof.PartialBatchedProof, evalsXOnAlpha, err = dkzg.BatchOpenSinglePoint(
		dkzgOpeningPolys,
		dkzgDigests,
		alpha,
		hFunc,
		pk.Vk.DKZGSRS,
	)

	if err != nil {
		return nil, err
	}

	if mpi.SelfRank != 0 {
		log.Debug().Dur("took", time.Since(start)).Msg("prover done")
		if err != nil {
			return nil, err
		}

		return proof, nil
	}

	// DBG check whether constraints are satisfied
	if err := checkConstraintX(
		pk,
		evalsXOnAlpha,
		zShiftedAlpha,
		wSmallY,
		etaY,
		etaX,
		gamma,
		lambda,
		alpha,
	); err != nil {
		return nil, err
	}

	polysCanonicalY := append(evalsXOnAlpha, zShiftedAlpha)
	for i := 0; i < len(polysCanonicalY); i++ {
		globalDomain[0].FFTInverse(polysCanonicalY[i], fft.DIF)
		fft.BitReverse(polysCanonicalY[i])
	}
	polysCanonicalY = append(polysCanonicalY, wCanonicalY)

	// compute Hy in canonical form
	hy1, hy2, hy3, hy4 := computeQuotientCanonicalY(pk,
		polysCanonicalY,
		etaY,
		etaX,
		gamma,
		lambda,
		alpha,
	)

	// compute kzg commitments of Hy1, Hy2 and Hy3
	if err := commitToQuotientOnY(hy1, hy2, hy3, hy4, proof, globalSRS); err != nil {
		return nil, err
	}
	// derive beta
	ts := []*curve.G1Affine{
		&proof.PartialBatchedProof.H,
	}
	for _, digest := range proof.PartialBatchedProof.ClaimedDigests {
		ts = append(ts, &digest)
	}
	for _, digest := range proof.Hy {
		ts = append(ts, &digest)
	}
	beta, err := deriveRandomness(&fs, "beta", true, ts...)
	if err != nil {
		return nil, err
	}

	// foldedHy = Hy1 + (beta**M)*Hy2 + (beta**(2M))*Hy3 + (beta**(3M))*Hy4
	var bBetaPowerM big.Int
	bSize.SetUint64(globalDomain[0].Cardinality)
	var betaPowerM fr.Element
	betaPowerM.Exp(beta, &bSize)
	betaPowerM.ToBigIntRegular(&bBetaPowerM)
	foldedHyDigest := proof.Hy[3]
	foldedHyDigest.ScalarMultiplication(&foldedHyDigest, &bBetaPowerM)
	foldedHyDigest.Add(&foldedHyDigest, &proof.Hy[2])
	foldedHyDigest.ScalarMultiplication(&foldedHyDigest, &bBetaPowerM)
	foldedHyDigest.Add(&foldedHyDigest, &proof.Hy[1])
	foldedHyDigest.ScalarMultiplication(&foldedHyDigest, &bBetaPowerM)
	foldedHyDigest.Add(&foldedHyDigest, &proof.Hy[0])
	foldedHy := hy4
	utils.Parallelize(len(foldedHy), func(start, end int) {
		for i := start; i < end; i++ {
			foldedHy[i].Mul(&foldedHy[i], &betaPowerM)
			foldedHy[i].Add(&foldedHy[i], &hy3[i])
			foldedHy[i].Mul(&foldedHy[i], &betaPowerM)
			foldedHy[i].Add(&foldedHy[i], &hy2[i])
			foldedHy[i].Mul(&foldedHy[i], &betaPowerM)
			foldedHy[i].Add(&foldedHy[i], &hy1[i])
		}
	})

	polysCanonicalY = append(polysCanonicalY, foldedHy)

	evalsOnBeta := evalPolynomialsAtPoint(polysCanonicalY, beta)
	var betaShifted fr.Element
	betaShifted.Mul(&beta, &globalDomain[0].Generator)
	// DBG check whether constraints are satisfied
	if err := checkConstraintY(pk.Vk,
		evalsOnBeta,
		eval(wCanonicalY, betaShifted),
		etaY,
		etaX,
		gamma,
		lambda,
		alpha,
		beta,
	); err != nil {
		return nil, err
	}

	var digestsY []curve.G1Affine
	digestsY = append(digestsY, proof.PartialBatchedProof.ClaimedDigests...)
	digestsY = append(digestsY, proof.PartialZShiftedProof.ClaimedDigest, proof.W, foldedHyDigest)
	proof.BatchedProof, err = kzg.BatchOpenSinglePoint(
		polysCanonicalY,
		digestsY,
		beta,
		hFunc,
		globalSRS,
	)
	
	proof.WShiftedProof, err = kzg.Open(
		wCanonicalY,
		betaShifted,
		globalSRS,
	)
	if err != nil {
		return nil, err
	}
	return proof, nil
}

// eval evaluates c at p
func eval(c []fr.Element, p fr.Element) fr.Element {
	var r fr.Element
	for i := len(c) - 1; i >= 0; i-- {
		r.Mul(&r, &p).Add(&r, &c[i])
	}
	return r
}

func evalPolynomialsAtPoint(polys [][]fr.Element, point fr.Element) []fr.Element {
	res := make([]fr.Element, len(polys))
	for i := range polys {
		res[i] = eval(polys[i], point)
	}
	return res
}

func commitToLRO(bcl, bcr, bco []fr.Element, proof *Proof, srs *dkzg.SRS) error {
	n := runtime.NumCPU() / 2
	var err error
	proof.LRO[0], err = dkzg.Commit(bcl, srs, n)
	if err != nil {
		return err
	}
	proof.LRO[1], err = dkzg.Commit(bcr, srs, n)
	if err != nil {
		return err
	}
	proof.LRO[2], err = dkzg.Commit(bco, srs, n)
	return err
}

func commitToQuotientX(h1, h2, h3, h4 []fr.Element, proof *Proof, srs *dkzg.SRS) error {
	n := runtime.NumCPU() / 2
	var err error
	proof.Hx[0], err = dkzg.Commit(h1, srs, n)
	if err != nil {
		return err
	}
	proof.Hx[1], err = dkzg.Commit(h2, srs, n)
	if err != nil {
		return err
	}
	proof.Hx[2], err = dkzg.Commit(h3, srs, n)
	if err != nil {
		return err
	}
	proof.Hx[3], err = dkzg.Commit(h4, srs, n)
	return err
}

func commitToQuotientOnY(h1, h2, h3, h4 []fr.Element, proof *Proof, srs *kzg.SRS) error {
	n := runtime.NumCPU() / 2
	var err error
	proof.Hy[0], err = kzg.Commit(h1, srs, n)
	if err != nil {
		return err
	}
	proof.Hy[1], err = kzg.Commit(h2, srs, n)
	if err != nil {
		return err
	}
	proof.Hy[2], err = kzg.Commit(h3, srs, n)
	if err != nil {
		return err
	}
	proof.Hy[3], err = kzg.Commit(h4, srs, n)
	return err
}

func computeLROCanonicalX(ll, lr, lo []fr.Element, domain *fft.Domain) (cl, cr, co []fr.Element) {
	cl = make([]fr.Element, domain.Cardinality)
	cr = make([]fr.Element, domain.Cardinality)
	co = make([]fr.Element, domain.Cardinality)

	copy(cl, ll)
	domain.FFTInverse(cl, fft.DIF)
	fft.BitReverse(cl)

	copy(cr, lr)
	domain.FFTInverse(cr, fft.DIF)
	fft.BitReverse(cr)

	copy(co, lo)
	domain.FFTInverse(co, fft.DIF)
	fft.BitReverse(co)
	return
}

// blindPoly blinds a polynomial by adding a Q(X)*(X**degree-1), where deg Q = order.
//
// * cp polynomial in canonical form
// * rou root of unity, meaning the blinding factor is multiple of X**rou-1
// * bo blinding order,  it's the degree of Q, where the blinding is Q(X)*(X**degree-1)
//
// WARNING:
// pre condition degree(cp) ⩽ rou + bo
// pre condition cap(cp) ⩾ int(totalDegree + 1)
func blindPoly(cp []fr.Element, rou, bo uint64) ([]fr.Element, error) {

	// degree of the blinded polynomial is max(rou+order, cp.Degree)
	totalDegree := rou + bo

	// re-use cp
	res := cp[:totalDegree+1]

	// random polynomial
	blindingPoly := make([]fr.Element, bo+1)
	for i := uint64(0); i < bo+1; i++ {
		if _, err := blindingPoly[i].SetRandom(); err != nil {
			return nil, err
		}
	}

	// blinding
	for i := uint64(0); i < bo+1; i++ {
		res[i].Sub(&res[i], &blindingPoly[i])
		res[rou+i].Add(&res[rou+i], &blindingPoly[i])
	}

	return res, nil

}

// evaluateLROSmallDomainX extracts the solution l, r, o, and returns it in lagrange form.
// solution = [ public | secret | internal ]
func evaluateLROSmallDomainX(spr *cs.SparseR1CS, pk *ProvingKey, solution []fr.Element) ([]fr.Element, []fr.Element, []fr.Element) {

	n := int(pk.Domain[0].Cardinality)

	var l, r, o []fr.Element
	l = make([]fr.Element, n)
	r = make([]fr.Element, n)
	o = make([]fr.Element, n)
	s0 := solution[0]

	if spr.NbPublicVariables > n {
		panic("The current circuit partition requires the public input be fitted in the first circuit.")
	}

	var offset int
	if mpi.SelfRank == 0 {
		for i := 0; i < spr.NbPublicVariables; i++ { // placeholders
			l[i].Set(&solution[i])
			r[i] = s0
			o[i] = s0
		}
		offset = spr.NbPublicVariables
	} else {
		offset = 0
	}

	start := int(mpi.SelfRank) * n + offset
	end := start - offset + n
	if end > len(spr.Constraints) + spr.NbPublicVariables {
		end = len(spr.Constraints) + spr.NbPublicVariables
	}
	for i := start; i < end; i++ { // constraints
		j := i % n
		ii := i - spr.NbPublicVariables
		l[j].Set(&solution[spr.Constraints[ii].L.WireID()])
		r[j].Set(&solution[spr.Constraints[ii].R.WireID()])
		o[j].Set(&solution[spr.Constraints[ii].O.WireID()])
	}
	offset += end - start
	if offset < 0 {
		offset = 0
	}
	for i := offset; i < n; i++ { // offset to reach 2**n constraints (where the id of l,r,o is 0, so we assign solution[0])
		l[i] = s0
		r[i] = s0
		o[i] = s0
	}

	return l, r, o
}

// computeZ computes z, in canonical basis, where:
//
// * z of degree n (domainNum.Cardinality)
// * z(1)=1
// 							       (l(g**k)+eta*(g**k)+gamma)*(r(g**k)+eta*u*(g**k)+gamma)*(o(g**k)+eta*(u**2)*(g**k)+gamma)
// * for i>0: z(g**i) = prod_{k<i} -------------------------------------------------------------------------------------------
//							         (l(g**k)+eta*s1(g**k)+gamma)*(r(g**k)+eta*s2(g**k)+gamma)*(o(g**k)+eta*s3(g**k)+gamma)
//
//	* l, r, o are the solution in Lagrange basis, evaluated on the small domain
func computeZCanonicalX(l, r, o []fr.Element, pk *ProvingKey, etaY, etaX, gamma fr.Element) ([]fr.Element, fr.Element, error) {
	// note that z has more capacity has its memory is reused for z later on
	z := make([]fr.Element, pk.Domain[0].Cardinality + 1)
	gInv := make([]fr.Element, pk.Domain[0].Cardinality + 1)

	z[0].SetOne()
	gInv[0].SetOne()

	IDys := getIDySmallDomain(globalDomain[0])
	IDxs := getIDxSmallDomain(&pk.Domain[0])

	var IDEtaY fr.Element
	IDEtaY.Mul(&IDys[mpi.SelfRank], &etaY)

	// var IDEtaY2 fr.Element
	// IDEtaY2.Exp(globalDomain[0].Generator, big.NewInt(int64(mpi.SelfRank))).Mul(&IDEtaY2, &etaY)
	// if !IDEtaY.Equal(&IDEtaY2) {
	// 	panic("IDEtaY != IDEtaY2")
	// }

	n := int(pk.Domain[0].Cardinality)
	utils.Parallelize(n, func(start, end int) {

		var f [3]fr.Element
		var g [3]fr.Element
		var t [3]fr.Element
		for i := start; i < end; i++ {
			f[0].Mul(&IDxs[i], &etaX).Add(&f[0], &IDEtaY).Add(&f[0], &l[i]).Add(&f[0], &gamma)
			f[1].Mul(&IDxs[i+n], &etaX).Add(&f[1], &IDEtaY).Add(&f[1], &r[i]).Add(&f[1], &gamma)
			f[2].Mul(&IDxs[i+2*n], &etaX).Add(&f[2], &IDEtaY).Add(&f[2], &o[i]).Add(&f[2], &gamma)

			t[0].Mul(&IDys[pk.PermutationY[i]], &etaY)
			t[1].Mul(&IDys[pk.PermutationY[i+n]], &etaY)
			t[2].Mul(&IDys[pk.PermutationY[i+2*n]], &etaY)
			g[0].Mul(&IDxs[pk.PermutationX[i]], &etaX).Add(&g[0], &t[0]).Add(&g[0], &l[i]).Add(&g[0], &gamma)
			g[1].Mul(&IDxs[pk.PermutationX[i+n]], &etaX).Add(&g[1], &t[1]).Add(&g[1], &r[i]).Add(&g[1], &gamma)
			g[2].Mul(&IDxs[pk.PermutationX[i+2*n]], &etaX).Add(&g[2], &t[2]).Add(&g[2], &o[i]).Add(&g[2], &gamma)

			f[0].Mul(&f[0], &f[1]).Mul(&f[0], &f[2])
			g[0].Mul(&g[0], &g[1]).Mul(&g[0], &g[2])
			
			gInv[i+1] = g[0]
			z[i+1] = f[0]
		}
	})

	gInv = fr.BatchInvert(gInv)
	for i := 0; i < n; i++ {
		z[i + 1].Mul(&z[i + 1], &z[i]).
			Mul(&z[i + 1], &gInv[i + 1])
	}

	pk.Domain[0].FFTInverse(z[:n], fft.DIF)
	fft.BitReverse(z[:n])

	return z[:n], z[n], nil
}

func computeWCanonicalY(selfProd fr.Element) ([]fr.Element, []fr.Element, *fr.Element, *fr.Element, error) {
	if mpi.SelfRank == 0 {
		W := make([]fr.Element, mpi.WorldSize + 1)
		W[0].SetOne()
		W[1] = selfProd
		for i := uint64(1); i < mpi.WorldSize; i++ {
			recvBuf, err := mpi.ReceiveBytes(fr.Bytes, i)
			if err != nil {
				return nil, nil, nil, nil, err
			}
			W[i + 1].SetBytes(recvBuf)
		}
		for i := uint64(1); i < mpi.WorldSize; i++ {
			W[i + 1].Mul(&W[i + 1], &W[i])
		}
		// DBG: Check whether the product is one.
		if !W[mpi.WorldSize].IsOne() {
			// wait for 10 seconds to see the output
			return nil, nil, nil, nil, fmt.Errorf("the product of Z is not one, got %v", W[mpi.WorldSize])
		}
		for i := uint64(1); i < mpi.WorldSize; i++ {
			// concatenate W[i].Bytes() and W[i+1].Bytes()
			a := W[i].Bytes()
			b:= W[i + 1].Bytes()
			sendBuf := make([]byte, len(a)+len(b))
			copy(sendBuf, a[:])
			copy(sendBuf[len(a):], b[:])
			if err := mpi.SendBytes(sendBuf, i); err != nil {
				return nil, nil, nil, nil, err
			}
		}
		wCanonicalY := make([]fr.Element, mpi.WorldSize)
		copy(wCanonicalY, W[:len(W) - 1])
		globalDomain[0].FFTInverse(wCanonicalY, fft.DIF)
		fft.BitReverse(wCanonicalY)
		return W[:len(W) - 1], wCanonicalY, &W[0], &W[1], nil
	} else {
		sendBuf := selfProd.Bytes()
		if err := mpi.SendBytes(sendBuf[:], 0); err != nil {
			return nil, nil, nil, nil, err
		}
		recvBuf, err := mpi.ReceiveBytes(2 * fr.Bytes, 0)
		if err != nil {
			return nil, nil, nil, nil, err
		}
		var l, r fr.Element
		l.SetBytes(recvBuf[:fr.Bytes])
		r.SetBytes(recvBuf[fr.Bytes:])
		return nil, nil, &l, &r, nil
	}
}

// evaluateXnMinusOneBig evalutes X^N-1 on DomainBig coset
func evaluateXnMinusOneBig(domainBig, domainSmall *fft.Domain) []fr.Element {
	ratio := domainBig.Cardinality / domainSmall.Cardinality
	res := make([]fr.Element, ratio)
	expo := big.NewInt(int64(domainSmall.Cardinality))
	res[0].Exp(domainBig.FrMultiplicativeGen, expo)

	var t fr.Element
	t.Exp(domainBig.Generator, big.NewInt(int64(domainSmall.Cardinality)))

	for i := 1; i < int(ratio); i++ {
		res[i].Mul(&res[i-1], &t)
	}

	var one fr.Element
	one.SetOne()
	for i := 0; i < int(ratio); i++ {
		res[i].Sub(&res[i], &one)
	}

	return res
}

// computeQuotientCanonicalX computes hx in canonical form, split as
// hx1 + (X**N)hx2 + (X**(2N))h3 + (X**(3N))h4 such that
//
// ql(X)l(X)+qr(X)r(X)+qm(X)l(X)r(X)+qo(X)o(X)+qk(X)
// + lambda * (
// 		(1 - L_{n-1}(X))(z(mu*X)*g1(X)*g2(X)*g3(X)-z(X)*f1(X)*f2(X)*f3(X))
//      L_{n-1}(X)*(cW*g1(X)*g2(X)*g3(X) - pW*z(X)*f1(X)*f2(X)*f3(X))
// )
// + (lambda**2) * L0(X)*(z(X)-1)
// = hx(X)Zn(X)
func computeQuotientCanonicalX(pk *ProvingKey, lCanonicalX, rCanonicalX, oCanonicalX, zCanonicalX []fr.Element, pW, cW, etaY, etaX, gamma, lambda fr.Element) ([]fr.Element, []fr.Element, []fr.Element, []fr.Element) {
	ratio := pk.Domain[1].Cardinality / pk.Domain[0].Cardinality

	// Compute the power of domain[1].Generator with bit-reversed order.
	factorsBR := make([]fr.Element, ratio)
	factorsBR[0].SetOne()
	for i := 1; i < int(ratio); i++ {
		factorsBR[i].Mul(&factorsBR[i-1], &pk.Domain[1].Generator)
	}
	fft.BitReverse(factorsBR)

	// Variables needed in permutation constraint.
	var cosetShiftX, cosetShiftSquareX fr.Element
	cosetShiftX.Set(&pk.Vk.CosetShift)
	cosetShiftSquareX.Mul(&cosetShiftX, &pk.Vk.CosetShift)
	var IDEtaY fr.Element
	IDEtaY.Exp(globalDomain[0].Generator, big.NewInt(int64(mpi.SelfRank))).Mul(&IDEtaY, &etaY)

	var one fr.Element
	one.SetOne()
	Lag0 := make([]fr.Element, pk.Domain[0].Cardinality)
	for i := 0; i < int(pk.Domain[0].Cardinality); i++ {
		Lag0[i].Set(&pk.Domain[0].CardinalityInv)
	}

	LagLst := make([]fr.Element, pk.Domain[0].Cardinality)
	LagLst[0].Set(&pk.Domain[0].CardinalityInv)
	for i := 1; i < int(pk.Domain[0].Cardinality); i++ {
		LagLst[i].Mul(&LagLst[i-1], &pk.Domain[0].Generator)
	}

	n := pk.Domain[0].Cardinality
	nn := uint64(64 - bits.TrailingZeros64(uint64(pk.Domain[0].Cardinality)))
	h := make([]fr.Element, pk.Domain[1].Cardinality)
	for _j := 0; _j < int(ratio); _j++ {
		// Compute FFT part for each polynomial.
		l0 := pk.Domain[0].FFTPart(Lag0, fft.DIF, factorsBR[_j], true)
		ll := pk.Domain[0].FFTPart(LagLst, fft.DIF, factorsBR[_j], true)

		sy1 := pk.Domain[0].FFTPart(pk.Sy1Canonical, fft.DIF, factorsBR[_j], true)
		sy2 := pk.Domain[0].FFTPart(pk.Sy2Canonical, fft.DIF, factorsBR[_j], true)
		sy3 := pk.Domain[0].FFTPart(pk.Sy3Canonical, fft.DIF, factorsBR[_j], true)
		sx1 := pk.Domain[0].FFTPart(pk.Sx1Canonical, fft.DIF, factorsBR[_j], true)
		sx2 := pk.Domain[0].FFTPart(pk.Sx2Canonical, fft.DIF, factorsBR[_j], true)
		sx3 := pk.Domain[0].FFTPart(pk.Sx3Canonical, fft.DIF, factorsBR[_j], true)
		z := pk.Domain[0].FFTPart(zCanonicalX, fft.DIF, factorsBR[_j], true)

		ql := pk.Domain[0].FFTPart(pk.Ql, fft.DIF, factorsBR[_j], true)
		qr := pk.Domain[0].FFTPart(pk.Qr, fft.DIF, factorsBR[_j], true)
		qm := pk.Domain[0].FFTPart(pk.Qm, fft.DIF, factorsBR[_j], true)
		qo := pk.Domain[0].FFTPart(pk.Qo, fft.DIF, factorsBR[_j], true)
		qk := pk.Domain[0].FFTPart(pk.Qk, fft.DIF, factorsBR[_j], true)

		l := pk.Domain[0].FFTPart(lCanonicalX, fft.DIF, factorsBR[_j], true)
		r := pk.Domain[0].FFTPart(rCanonicalX, fft.DIF, factorsBR[_j], true)
		o := pk.Domain[0].FFTPart(oCanonicalX, fft.DIF, factorsBR[_j], true)

		hStart := uint64(_j) * n
		utils.Parallelize(int(n), func(start, end int) {
			var f, g, t [3]fr.Element
			var oneMinusLL fr.Element
			var t0, t1 fr.Element
			var IDEtaX fr.Element
			IDEtaX.Exp(pk.Domain[0].Generator, big.NewInt(int64(start))).
				Mul(&IDEtaX, &factorsBR[_j]).
				Mul(&IDEtaX, &pk.Domain[1].FrMultiplicativeGen).
				Mul(&IDEtaX, &etaX)
			
			for i := uint64(start); i < uint64(end); i++ {
				_i := bits.Reverse64(uint64(i)) >> nn
				_is := bits.Reverse64(uint64((i + 1)) & (n - 1)) >> nn

				// Compute permutation constraints L0(X)*(z(X)-1)
				h[hStart + _i].Sub(&z[_i], &one).Mul(&h[hStart + _i], &l0[_i])
				
				// Compute permutation constraints 
				// (1 - L_{n - 1}(X))z(mu*X)*g1(X)*g2(X)*g3(X) - z(X)*f1(X)*f2(X)*f3(X)
				// + L_{n-1}(X)*(cW*g1(X)*g2(X)*g3(X) - pW*z(X)*f1(X)*f2(X)*f3(X))
				f[0].Add(&IDEtaX, &IDEtaY).Add(&f[0], &l[_i]).Add(&f[0], &gamma)
				f[1].Mul(&IDEtaX, &cosetShiftX).Add(&f[1], &IDEtaY).Add(&f[1], &r[_i]).Add(&f[1], &gamma)
				f[2].Mul(&IDEtaX, &cosetShiftSquareX).Add(&f[2], &IDEtaY).Add(&f[2], &o[_i]).Add(&f[2], &gamma)
				f[0].Mul(&f[0], &f[1]).Mul(&f[0], &f[2])

				t[0].Mul(&sy1[_i], &etaY)
				t[1].Mul(&sy2[_i], &etaY)
				t[2].Mul(&sy3[_i], &etaY)
				g[0].Mul(&sx1[_i], &etaX).Add(&g[0], &t[0]).Add(&g[0], &l[_i]).Add(&g[0], &gamma)
				g[1].Mul(&sx2[_i], &etaX).Add(&g[1], &t[1]).Add(&g[1], &r[_i]).Add(&g[1], &gamma)
				g[2].Mul(&sx3[_i], &etaX).Add(&g[2], &t[2]).Add(&g[2], &o[_i]).Add(&g[2], &gamma)
				g[0].Mul(&g[0], &g[1]).Mul(&g[0], &g[2])
				
				oneMinusLL.Sub(&one, &ll[_i])
				t0.Mul(&f[0], &z[_i])
				t1.Mul(&g[0], &z[_is])
				t1.Sub(&t1, &t0).Mul(&t1, &oneMinusLL)
				h[hStart + _i].Mul(&h[hStart + _i], &lambda).Add(&h[hStart + _i], &t1)

				t0.Mul(&t0, &pW)
				t1.Mul(&g[0], &cW)
				t1.Sub(&t1, &t0).Mul(&t1, &ll[_i])
				h[hStart + _i].Add(&h[hStart + _i], &t1)
				IDEtaX.Mul(&IDEtaX, &pk.Domain[0].Generator)

				// Compute gate constraint
				t1.Mul(&qm[_i], &r[_i])
				t1.Add(&t1, &ql[_i])
				t1.Mul(&t1, &l[_i])
	
				t0.Mul(&qr[_i], &r[_i])
				t0.Add(&t0, &t1)
	
				t1.Mul(&qo[_i], &o[_i])
				t0.Add(&t0, &t1).Add(&t0, &qk[_i])
				h[hStart + _i].Mul(&h[hStart + _i], &lambda).Add(&h[hStart + _i], &t0)
			}
		})
	}

	XnMinusOneInv := evaluateXnMinusOneBig(&pk.Domain[1], &pk.Domain[0])
	XnMinusOneInv = fr.BatchInvert(XnMinusOneInv)
	nn2 := uint64(64 - bits.TrailingZeros64(uint64(pk.Domain[1].Cardinality)))
	utils.Parallelize(int(pk.Domain[1].Cardinality), func(start, end int) {
		for _i := uint64(start); _i < uint64(end); _i++ {
			i := bits.Reverse64(_i) >> nn2
			h[_i].Mul(&h[_i], &XnMinusOneInv[i % ratio])
		}
	})
	pk.Domain[1].FFTInverse(h, fft.DIT, true)

	h1 := h[:n]
	h2 := h[n: 2*n]
	h3 := h[2*n: 3*n]
	h4 := h[3*n: 4*n]

	for i := int(4 * n); i < len(h); i++ {
		fmt.Println(h[i].String())
		// if !h[i].IsZero() {
		// 	panic("invalid proof: wrong h degree")
		// }
	}

	return h1, h2, h3, h4
}

// computeQuotientCanonicalY computes Hy in canonical form, split as
// Hy1 + (Y**M)Hy2 + (Y**(2M))Hy3 + (Y**(3M))Hy4 such that
//
// Ql(Y, alpha)L(Y, alpha)+Qr(Y, alpha)R(Y, alpha)+Qm(Y, alpha)L(Y, alpha)R(Y, alpha)+Qo(Y, alpha)O(Y, alpha)+Qk(Y, alpha)
// + lambda * (
// 		(1 - Lx_{n-1}(X)) (Z(Y, omegaX*alpha)*G1(Y, alpha)*G2(Y, alpha)*G3(Y, alpha) - Z(Y, alpha)*F1(Y, alpha)*F2(Y, alpha)*F3(Y, alpha))
// 		+ Lx_{n-1}(X) (W(omegaY*Y)*G1(Y, alpha)*G2(Y, alpha)*G3(Y, alpha) - W(Y)*Z(Y, alpha)*F1(Y, alpha)*F2(Y, alpha)*F3(Y, alpha))
// )
// + lambda**2 * Lx0(alpha)*(Z(Y, alpha) - 1)
// + lambda**3 * Ly0(Y)(W(Y) - 1)
// - Hx(Y, alpha)Zn(X) = Hy(Y)Zm(Y)
func computeQuotientCanonicalY(pk *ProvingKey, polys [][]fr.Element, etaY, etaX, gamma, lambda, alpha fr.Element) ([]fr.Element, []fr.Element, []fr.Element, []fr.Element) {
	h := make([]fr.Element, globalDomain[1].Cardinality)
	ratio := globalDomain[1].Cardinality / globalDomain[0].Cardinality

	// Compute the power of globalDomain[1].Generator with bit-reversed order.
	factorsBR := make([]fr.Element, ratio)
	factorsBR[0].SetOne()
	for i := 1; i < int(ratio); i++ {
		factorsBR[i].Mul(&factorsBR[i-1], &globalDomain[1].Generator)
	}
	fft.BitReverse(factorsBR)

	// Variables needed in permutation constraint.
	n := globalDomain[0].Cardinality
	var IDEtaX, IDCosetShiftEtaX, IDCosetShiftSquareEtaX fr.Element
	IDEtaX.Mul(&alpha, &etaX)
	IDCosetShiftEtaX.Mul(&IDEtaX, &pk.Vk.CosetShift)
	IDCosetShiftSquareEtaX.Mul(&IDCosetShiftEtaX, &pk.Vk.CosetShift)

	var one fr.Element
	one.SetOne()

	var lx0, lxl, oneMinusLxL, den fr.Element
	lx0.Exp(alpha, big.NewInt(int64(pk.Domain[0].Cardinality))).
		Sub(&lx0, &one)
	lxl.Set(&lx0)
	den.Sub(&alpha, &one).Inverse(&den)
	lx0.Mul(&lx0, &den).Mul(&lx0, &pk.Domain[0].CardinalityInv)
	den.Sub(&alpha, &pk.Domain[0].GeneratorInv).
		Inverse(&den)
	lxl.Mul(&lxl, &den).Mul(&lxl, &pk.Domain[0].GeneratorInv).Mul(&lxl, &pk.Domain[0].CardinalityInv)
	oneMinusLxL.Sub(&one, &lxl)

	LagY0 := make([]fr.Element, globalDomain[0].Cardinality)
	for i := 0; i < int(globalDomain[0].Cardinality); i++ {
		LagY0[i].Set(&globalDomain[0].CardinalityInv)
	}

	var vanishingX fr.Element
	vanishingX.Exp(alpha, big.NewInt(int64(pk.Domain[0].Cardinality)))
	vanishingX.Sub(&vanishingX, &one)

	nn := uint64(64 - bits.TrailingZeros64(uint64(globalDomain[0].Cardinality)))
	for _j := 0; _j < int(ratio); _j++ {
		// Compute FFT part for each polynomial.
		foldedHx := globalDomain[0].FFTPart(polys[0], fft.DIF, factorsBR[_j], true)
		l := globalDomain[0].FFTPart(polys[1], fft.DIF, factorsBR[_j], true)
		r := globalDomain[0].FFTPart(polys[2], fft.DIF, factorsBR[_j], true)
		o := globalDomain[0].FFTPart(polys[3], fft.DIF, factorsBR[_j], true)
		ql := globalDomain[0].FFTPart(polys[4], fft.DIF, factorsBR[_j], true)
		qr := globalDomain[0].FFTPart(polys[5], fft.DIF, factorsBR[_j], true)
		qm := globalDomain[0].FFTPart(polys[6], fft.DIF, factorsBR[_j], true)
		qo := globalDomain[0].FFTPart(polys[7], fft.DIF, factorsBR[_j], true)
		qk := globalDomain[0].FFTPart(polys[8], fft.DIF, factorsBR[_j], true)
		sy1 := globalDomain[0].FFTPart(polys[9], fft.DIF, factorsBR[_j], true)
		sy2 := globalDomain[0].FFTPart(polys[10], fft.DIF, factorsBR[_j], true)
		sy3 := globalDomain[0].FFTPart(polys[11], fft.DIF, factorsBR[_j], true)
		sx1 := globalDomain[0].FFTPart(polys[12], fft.DIF, factorsBR[_j], true)
		sx2 := globalDomain[0].FFTPart(polys[13], fft.DIF, factorsBR[_j], true)
		sx3 := globalDomain[0].FFTPart(polys[14], fft.DIF, factorsBR[_j], true)
		z := globalDomain[0].FFTPart(polys[15], fft.DIF, factorsBR[_j], true)
		zs := globalDomain[0].FFTPart(polys[16], fft.DIF, factorsBR[_j], true)
		w := globalDomain[0].FFTPart(polys[17], fft.DIF, factorsBR[_j], true)
		ly0 := globalDomain[0].FFTPart(LagY0, fft.DIF, factorsBR[_j], true)

		hStart := uint64(_j) * n
		utils.Parallelize(int(n), func(start, end int) {
			var f, g, t [3]fr.Element
			var t0, t1 fr.Element
			var IDEtaY fr.Element
			IDEtaY.Exp(globalDomain[0].Generator, big.NewInt(int64(start))).
				Mul(&IDEtaY, &factorsBR[_j]).
				Mul(&IDEtaY, &globalDomain[1].FrMultiplicativeGen).Mul(&IDEtaY, &etaY)
			for i := uint64(start); i < uint64(end); i++ {
				_i := bits.Reverse64(uint64(i)) >> nn
				_is := bits.Reverse64(uint64((i + 1)) & (n - 1)) >> nn
				// Compute the permutation constraint Ly0(Y)(W(Y) - 1)
				h[hStart + _i].Sub(&w[_i], &one).Mul(&h[hStart + _i], &ly0[_i])

				// Compute the permutation constraint Lx0(alpha)(Z(Y, alpha) - 1)
				t0.Sub(&z[_i], &one).Mul(&t0, &lx0)
				h[hStart + _i].Mul(&h[hStart + _i], &lambda).Add(&h[hStart + _i], &t0)

				// Compute the permutation constraint
				// (1 - Lx_{n - 1}(X))(Z(Y, omegaX*alpha)()()() - Z(Y, alpha)()()())
				// + Lx_{n - 1}(X)(W(omegaY*Y)()()() - W(Y)*Z(Y, alpha)()()())
				f[0].Add(&IDEtaY, &IDEtaX).Add(&f[0], &l[_i]).Add(&f[0], &gamma)
				f[1].Add(&IDEtaY, &IDCosetShiftEtaX).Add(&f[1], &r[_i]).Add(&f[1], &gamma)
				f[2].Add(&IDEtaY, &IDCosetShiftSquareEtaX).Add(&f[2], &o[_i]).Add(&f[2], &gamma)
				f[0].Mul(&f[0], &f[1]).Mul(&f[0], &f[2])

				t[0].Mul(&sy1[_i], &etaY)
				t[1].Mul(&sy2[_i], &etaY)
				t[2].Mul(&sy3[_i], &etaY)
				g[0].Mul(&sx1[_i], &etaX).Add(&g[0], &t[0]).Add(&g[0], &l[_i]).Add(&g[0], &gamma)
				g[1].Mul(&sx2[_i], &etaX).Add(&g[1], &t[1]).Add(&g[1], &r[_i]).Add(&g[1], &gamma)
				g[2].Mul(&sx3[_i], &etaX).Add(&g[2], &t[2]).Add(&g[2], &o[_i]).Add(&g[2], &gamma)
				g[0].Mul(&g[0], &g[1]).Mul(&g[0], &g[2])

				t0.Mul(&f[0], &z[_i])
				t1.Mul(&g[0], &zs[_i])
				t1.Sub(&t1, &t0).Mul(&t1, &oneMinusLxL)
				h[hStart + _i].Mul(&h[hStart + _i], &lambda).Add(&h[hStart + _i], &t1)

				t0.Mul(&t0, &w[_i])
				t1.Mul(&g[0], &w[_is])
				t1.Sub(&t1, &t0).Mul(&t1, &lxl)
				h[hStart + _i].Add(&h[hStart + _i], &t1)
				IDEtaY.Mul(&IDEtaY, &globalDomain[0].Generator)

				// Compute the gate constraint.
				t1.Mul(&qm[_i], &r[_i])
				t1.Add(&t1, &ql[_i])
				t1.Mul(&t1, &l[_i])
	
				t0.Mul(&qr[_i], &r[_i])
				t0.Add(&t0, &t1)
	
				t1.Mul(&qo[_i], &o[_i])
				t0.Add(&t0, &t1)
				t0.Add(&t0, &qk[_i])
				h[hStart + _i].Mul(&h[hStart + _i], &lambda).Add(&h[hStart + _i], &t0)

				// Remove Hx(Y, alpha) * (alpha^N - 1)
				t0.Mul(&foldedHx[_i], &vanishingX)
				h[hStart + _i].Sub(&h[hStart + _i], &t0)
			}
		})
	}

	evaluationYmMinusOneInverse := evaluateXnMinusOneBig(globalDomain[1], globalDomain[0])
	evaluationYmMinusOneInverse = fr.BatchInvert(evaluationYmMinusOneInverse)
	nn2 := uint64(64 - bits.TrailingZeros64(uint64(globalDomain[1].Cardinality)))
	utils.Parallelize(int(globalDomain[1].Cardinality), func(start, end int) {
		for _i := uint64(start); _i < uint64(end); _i++ {
			i := bits.Reverse64(_i) >> nn2
			h[_i].Mul(&h[_i], &evaluationYmMinusOneInverse[i % ratio])
		}
	})

	globalDomain[1].FFTInverse(h, fft.DIT, true)

	h1 := h[:n]
	h2 := h[n : 2*n]
	h3 := h[2*n : 3*n]
	h4 := h[3*n : 4*n]
	return h1, h2, h3, h4
}

// checkConstraintX checks that the constraint is satisfied
func checkConstraintX(pk *ProvingKey, evalsXOnAlpha [][]fr.Element, zShiftedAlpha, wSmallY []fr.Element, etaY, etaX, gamma, lambda, alpha fr.Element) error {
	n := int64(pk.Domain[0].Cardinality)
	var l0, ll, oneMinusLL, one, den fr.Element
	one.SetOne()

	l0.Exp(alpha, big.NewInt(n)).Sub(&l0, &one)
	ll.Set(&l0)
	den.Sub(&alpha, &one).Inverse(&den)
	l0.Mul(&l0, &den).Mul(&l0, &pk.Domain[0].CardinalityInv)

	den.Sub(&alpha, &pk.Domain[0].GeneratorInv).Inverse(&den)
	ll.Mul(&ll, &den).Mul(&ll, &pk.Domain[0].CardinalityInv).Mul(&ll, &pk.Domain[0].GeneratorInv)
	oneMinusLL.Sub(&one, &ll)
	for k := 0; k < int(mpi.WorldSize); k++ {
		// unpack vector evalsXOnAlpha on hx, l, r, o, ql, qr, qm, qo, qk, s1, s2, s3, z
		hx := evalsXOnAlpha[0][k]
		l := evalsXOnAlpha[1][k]
		r := evalsXOnAlpha[2][k]
		o := evalsXOnAlpha[3][k]
		ql := evalsXOnAlpha[4][k]
		qr := evalsXOnAlpha[5][k]
		qm := evalsXOnAlpha[6][k]
		qo := evalsXOnAlpha[7][k]
		qk := evalsXOnAlpha[8][k]
		sy1 := evalsXOnAlpha[9][k]
		sy2 := evalsXOnAlpha[10][k]
		sy3 := evalsXOnAlpha[11][k]
		sx1 := evalsXOnAlpha[12][k]
		sx2 := evalsXOnAlpha[13][k]
		sx3 := evalsXOnAlpha[14][k]
		z := evalsXOnAlpha[15][k]
		zs := zShiftedAlpha[k]
		pw := wSmallY[k]
		cw := wSmallY[(k + 1)%int(mpi.WorldSize)]
		var IDEtaY fr.Element
		IDEtaY.Exp(globalDomain[0].Generator, big.NewInt(int64(k))).Mul(&IDEtaY, &etaY)

		// first part: individual constraints
		var firstPart fr.Element
		ql.Mul(&ql, &l)
		qr.Mul(&qr, &r)
		qm.Mul(&qm, &l).Mul(&qm, &r)
		qo.Mul(&qo, &o)
		firstPart.Add(&ql, &qr).Add(&firstPart, &qm).Add(&firstPart, &qo).Add(&firstPart, &qk)

		// second part:
		// (1 - L_{n - 1})(z(, omegaX * alpha)()()() - z(, alpha)()()())
		// + L_{n - 1}(cw * ()()() - pw * z(, alpha)()()())
		var prodfz, prodg fr.Element
		sy1.Mul(&sy1, &etaY)
		sy2.Mul(&sy2, &etaY)
		sy3.Mul(&sy3, &etaY)
		sx1.Mul(&sx1, &etaX).Add(&sx1, &sy1).Add(&sx1, &l).Add(&sx1, &gamma)
		sx2.Mul(&sx2, &etaX).Add(&sx2, &sy2).Add(&sx2, &r).Add(&sx2, &gamma)
		sx3.Mul(&sx3, &etaX).Add(&sx3, &sy3).Add(&sx3, &o).Add(&sx3, &gamma)
		prodg.Mul(&sx1, &sx2).Mul(&prodg, &sx3)

		var ualpha, uualpha fr.Element
		ualpha.Mul(&alpha, &pk.Vk.CosetShift)
		uualpha.Mul(&ualpha, &pk.Vk.CosetShift)

		var tmp fr.Element
		prodfz.Mul(&etaX, &alpha).Add(&prodfz, &IDEtaY).Add(&prodfz, &l).Add(&prodfz, &gamma)
		tmp.Mul(&etaX, &ualpha).Add(&tmp, &IDEtaY).Add(&tmp, &r).Add(&tmp, &gamma)
		prodfz.Mul(&prodfz, &tmp)
		tmp.Mul(&etaX, &uualpha).Add(&tmp, &IDEtaY).Add(&tmp, &o).Add(&tmp, &gamma)
		prodfz.Mul(&prodfz, &tmp).Mul(&prodfz, &z)

		var secondPart, case1, case2 fr.Element
		case1.Mul(&prodg, &zs).Sub(&case1, &prodfz).Mul(&case1, &oneMinusLL)
		prodfz.Mul(&prodfz, &pw)
		case2.Mul(&prodg, &cw).Sub(&case2, &prodfz).Mul(&case2, &ll)
		secondPart.Add(&case1, &case2)
		
		// third part Lx0(alpha)*(Z(Y, alpha) - 1)
		var thirdPart fr.Element
		thirdPart.Sub(&z, &one).Mul(&thirdPart, &l0)

		// Put it all together
		var result fr.Element
		result.Mul(&thirdPart, &lambda).Add(&result, &secondPart).Mul(&result, &lambda).Add(&result, &firstPart)

		var vanishingX fr.Element
		vanishingX.Exp(alpha, big.NewInt(int64(pk.Domain[0].Cardinality)))
		vanishingX.Sub(&vanishingX, &one)

		var vH fr.Element
		vH.Mul(&hx, &vanishingX)
		result.Sub(&result, &vH)

		// if result != 0 return error
		if !result.IsZero() {
			return fmt.Errorf("constraints on X are not satisfied on %d: got %s, want 0", k, result.String())
		}
	}
	return nil
}
