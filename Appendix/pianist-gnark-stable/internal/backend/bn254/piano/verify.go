// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

// Modifications Copyright 2023 Tianyi Liu and Tiancheng Xie

package piano

import (
	"crypto/sha256"
	"fmt"
	"math/big"
	"runtime/debug"
	"time"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"github.com/sunblaze-ucb/simpleMPI/mpi"

	curve "github.com/consensys/gnark-crypto/ecc/bn254"
	bn254witness "github.com/consensys/gnark/internal/backend/bn254/witness"

	"github.com/consensys/gnark-crypto/fiat-shamir"
	"github.com/consensys/gnark/logger"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr/dkzg"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr/kzg"
)

func Verify(proof *Proof, vk *VerifyingKey, publicWitness bn254witness.Witness) error {
	log := logger.Logger().With().Str("curve", "bn254").Str("backend", "piano").Logger()
	start := time.Now()

	// pick a hash function to derive the challenge (the same as in the prover)
	hFunc := sha256.New()

	// transcript to derive the challenge
	fs := fiatshamir.NewTranscript(hFunc, "gamma", "eta", "lambda", "alpha", "beta")

	// The first challenge is derived using the public data: the commitments to the permutation,
	// the coefficients of the circuit, and the public inputs.
	// derive gamma from the Comm(blinded cl), Comm(blinded cr), Comm(blinded co)
	if err := bindPublicData(&fs, "gamma", *vk, publicWitness); err != nil {
		return err
	}
	gamma, err := deriveRandomness(&fs, "gamma", true, &proof.LRO[0], &proof.LRO[1], &proof.LRO[2])
	if err != nil {
		return err
	}
	// derive eta from Comm(l), Comm(r), Comm(o)
	eta, err := deriveRandomness(&fs, "eta", true)
	if err != nil {
		return err
	}

	// derive lambda from Comm(l), Comm(r), Comm(o), Com(Z)
	lambda, err := deriveRandomness(&fs, "lambda", true, &proof.Z)
	if err != nil {
		return err
	}

	// derive alpha, the point of evaluation
	alpha, err := deriveRandomness(&fs, "alpha", true, &proof.Hx[0], &proof.Hx[1], &proof.Hx[2])
	if err != nil {
		return err
	}

	// evaluation of Z=Xⁿ⁻¹ at α
	var alphaPowerN, zalpha fr.Element
	var bExpo big.Int
	one := fr.One()
	bExpo.SetUint64(vk.SizeX)
	alphaPowerN.Exp(alpha, &bExpo)
	zalpha.Sub(&alphaPowerN, &one)

	// compute the folded commitment to H: Comm(h₁) + αᵐ*Comm(h₂) + α²⁽ᵐ⁾*Comm(h₃)
	var alphaNBigInt big.Int
	alphaPowerN.ToBigIntRegular(&alphaNBigInt)
	foldedHxDigest := proof.Hx[2]
	foldedHxDigest.ScalarMultiplication(&foldedHxDigest, &alphaNBigInt)
	foldedHxDigest.Add(&foldedHxDigest, &proof.Hx[1])
	foldedHxDigest.ScalarMultiplication(&foldedHxDigest, &alphaNBigInt)
	foldedHxDigest.Add(&foldedHxDigest, &proof.Hx[0])

	foldedPartialProof, foldedPartialDigest, err := dkzg.FoldProof(
		[]dkzg.Digest{
			foldedHxDigest,
			proof.LRO[0],
			proof.LRO[1],
			proof.LRO[2],
			vk.Ql,
			vk.Qr,
			vk.Qm,
			vk.Qo,
			vk.Qk,
			vk.S[0],
			vk.S[1],
			vk.S[2],
			proof.Z,
		},
		&proof.PartialBatchedProof,
		alpha,
		hFunc)

	if err != nil {
		return fmt.Errorf("failed to fold proof on X = alpha: %v", err)
	}
	// Batch verify
	var shiftedalpha fr.Element
	shiftedalpha.Mul(&alpha, &vk.Generator)
	err = dkzg.BatchVerifyMultiPoints(
		[]dkzg.Digest{
			foldedPartialDigest,
			proof.Z,
		},
		[]dkzg.OpeningProof{
			foldedPartialProof,
			proof.PartialZShiftedProof,
		},
		[]fr.Element{
			alpha,
			shiftedalpha,
		},
		vk.DKZGSRS,
	)
	if err != nil {
		return fmt.Errorf("failed to batch verify on X = alpha: %v", err)
	}

	// derive beta
	ts := []*curve.G1Affine{
		&proof.PartialBatchedProof.H,
	}
	for _, digest := range proof.PartialBatchedProof.ClaimedDigests {
		ts = append(ts, &digest)
	}
	for _, digest := range proof.Hy {
		ts = append(ts, &digest)
	}
	beta, err := deriveRandomness(&fs, "beta", true, ts...)
	if err != nil {
		return err
	}

	if err := checkConstraintY(vk, proof.BatchedProof.ClaimedValues, gamma, eta, lambda, alpha, beta); err != nil {
		return err
	}
	// foldedHy = Hy1 + (beta**M)*Hy2 + (beta**(2M))*Hy3
	var bBetaPowerM, bSize big.Int
	bSize.SetUint64(vk.SizeY)
	var betaPowerM fr.Element
	betaPowerM.Exp(beta, &bSize)
	betaPowerM.ToBigIntRegular(&bBetaPowerM)
	foldedHyDigest := proof.Hy[2]                                      // Hy3
	foldedHyDigest.ScalarMultiplication(&foldedHyDigest, &bBetaPowerM) // (beta**M)*Hy3
	foldedHyDigest.Add(&foldedHyDigest, &proof.Hy[1])                  // (beta**M)*Hy3 + Hy2
	foldedHyDigest.ScalarMultiplication(&foldedHyDigest, &bBetaPowerM) // (beta**(2M))*Hy3 + (beta**M)*Hy2
	foldedHyDigest.Add(&foldedHyDigest, &proof.Hy[0])                  // (beta**(2M))*Hy3 + (beta**M)*Hy2 + Hy1

	if err := kzg.BatchVerifySinglePoint(
		append(proof.PartialBatchedProof.ClaimedDigests,
			proof.PartialZShiftedProof.ClaimedDigest,
			foldedHyDigest,
		),
		&proof.BatchedProof,
		beta, // not consistent with the prover
		hFunc,
		vk.KZGSRS,
	); err != nil {
		return err
	}

	log.Debug().Dur("took", time.Since(start)).Msg("verifier done")

	return err
}

// unpack unpacks evaluations from an array
func unpack(src []fr.Element, dst ...*fr.Element) {
	for i := range dst {
		*dst[i] = src[i]
	}
}

func bindPublicData(fs *fiatshamir.Transcript, challenge string, vk VerifyingKey, publicInputs []fr.Element) error {
	// permutation
	if err := fs.Bind(challenge, vk.S[0].Marshal()); err != nil {
		return err
	}
	if err := fs.Bind(challenge, vk.S[1].Marshal()); err != nil {
		return err
	}
	if err := fs.Bind(challenge, vk.S[2].Marshal()); err != nil {
		return err
	}

	// coefficients
	if err := fs.Bind(challenge, vk.Ql.Marshal()); err != nil {
		return err
	}
	if err := fs.Bind(challenge, vk.Qr.Marshal()); err != nil {
		return err
	}
	if err := fs.Bind(challenge, vk.Qm.Marshal()); err != nil {
		return err
	}
	if err := fs.Bind(challenge, vk.Qo.Marshal()); err != nil {
		return err
	}
	if err := fs.Bind(challenge, vk.Qk.Marshal()); err != nil {
		return err
	}

	return nil
}

func deriveRandomness(fs *fiatshamir.Transcript, challenge string, notSend bool, points ...*curve.G1Affine) (fr.Element, error) {
	if mpi.SelfRank == 0 {
		var buf [curve.SizeOfG1AffineUncompressed]byte
		var r fr.Element

		for _, p := range points {
			buf = p.RawBytes()
			if err := fs.Bind(challenge, buf[:]); err != nil {
				fmt.Println("deriveRandomness", challenge, "err", err)
				fmt.Println("Stack", string(debug.Stack()))
				return r, err
			}
		}

		b, err := fs.ComputeChallenge(challenge)
		if err != nil {
			fmt.Println("deriveRandomness", challenge, "err", err)
			fmt.Println("Stack", string(debug.Stack()))
			return r, err
		}
		r.SetBytes(b)
		if notSend {
			return r, nil
		}
		sendBuf := r.Bytes()
		for i := 1; i < int(mpi.WorldSize); i++ {
			mpi.SendBytes(sendBuf[:], uint64(i))
		}
		return r, nil
	} else {
		var r fr.Element
		recvBuf, err := mpi.ReceiveBytes(fr.Bytes, 0)
		if err != nil {
			return r, err
		}
		r.SetBytes(recvBuf)
		return r, nil
	}
}

// checkConstraintY checks that the constraint is satisfied
func checkConstraintY(vk *VerifyingKey, evalsYOnBeta []fr.Element, gamma, eta, lambda, alpha, beta fr.Element) error {
	// unpack vector evalsXOnAlpha on l, r, o, ql, qr, qm, qo, qk, s1, s2, s3, z, zs
	hx := evalsYOnBeta[0]
	l := evalsYOnBeta[1]
	r := evalsYOnBeta[2]
	o := evalsYOnBeta[3]
	ql := evalsYOnBeta[4]
	qr := evalsYOnBeta[5]
	qm := evalsYOnBeta[6]
	qo := evalsYOnBeta[7]
	qk := evalsYOnBeta[8]
	s1 := evalsYOnBeta[9]
	s2 := evalsYOnBeta[10]
	s3 := evalsYOnBeta[11]
	z := evalsYOnBeta[12]
	zs := evalsYOnBeta[13]
	hy := evalsYOnBeta[14]
	// first part: individual constraints
	var firstPart fr.Element
	ql.Mul(&ql, &l)
	qr.Mul(&qr, &r)
	qm.Mul(&qm, &l).Mul(&qm, &r)
	qo.Mul(&qo, &o)
	firstPart.Add(&ql, &qr).Add(&firstPart, &qm).Add(&firstPart, &qo).Add(&firstPart, &qk)
	// fmt.Printf("firstPart: %s\n", firstPart.String())

	// second part:
	// (L(beta, alpha)+eta*S1(beta, alpha)+gamma)*(R(beta, alpha)+eta*S2(beta, alpha)+gamma)*(O(beta, alpha)+eta*S3(alpha)+gamma) * Z(beta,mu*alpha)
	// - (L(beta, alpha)+eta*id1(beta, alpha)+gamma)*(R(beta, alpha)+eta*id2(beta, alpha)+gamma)*(O(beta, alpha)+eta*id3(beta, alpha)+gamma)*Z(beta, alpha)
	s1.Mul(&s1, &eta).Add(&s1, &l).Add(&s1, &gamma)
	s2.Mul(&s2, &eta).Add(&s2, &r).Add(&s2, &gamma)
	s3.Mul(&s3, &eta).Add(&s3, &o).Add(&s3, &gamma)
	s1.Mul(&s1, &s2).Mul(&s1, &s3).Mul(&s1, &zs)

	var alphaEta, ualphaEta, uualphaEta fr.Element
	alphaEta.Mul(&alpha, &eta)
	ualphaEta.Mul(&alphaEta, &vk.CosetShift)
	uualphaEta.Mul(&ualphaEta, &vk.CosetShift)

	var secondPart, tmp fr.Element
	secondPart.Add(&alphaEta, &l).Add(&secondPart, &gamma)
	tmp.Add(&ualphaEta, &r).Add(&tmp, &gamma)
	secondPart.Mul(&secondPart, &tmp)
	tmp.Add(&uualphaEta, &o).Add(&tmp, &gamma)
	secondPart.Mul(&secondPart, &tmp).Mul(&secondPart, &z)
	secondPart.Sub(&s1, &secondPart)

	// third part L0(alpha)*(Z(beta, alpha) - 1)
	var thirdPart, one, den fr.Element
	one.SetOne()
	z.Sub(&z, &one)
	nbElmt := int64(vk.SizeX)
	thirdPart.Set(&alpha).
		Exp(thirdPart, big.NewInt(nbElmt)).
		Sub(&thirdPart, &one)
	den.Sub(&alpha, &one).
		Inverse(&den)
	thirdPart.Mul(&thirdPart, &den).
		Mul(&thirdPart, &vk.SizeXInv).
		Mul(&thirdPart, &z)

	// Put it all together
	var result fr.Element
	result.Mul(&thirdPart, &lambda).Add(&result, &secondPart).Mul(&result, &lambda).Add(&result, &firstPart)

	var vanishingX fr.Element
	vanishingX.Exp(alpha, big.NewInt(int64(vk.SizeX)))
	vanishingX.Sub(&vanishingX, &one)

	// print all elements
	// fmt.Println("hx", hx)
	// fmt.Println("l", l)
	// fmt.Println("r", r)
	// fmt.Println("o", o)
	// fmt.Println("ql", ql)
	// fmt.Println("qr", qr)
	// fmt.Println("qm", qm)
	// fmt.Println("qo", qo)
	// fmt.Println("qk", qk)
	// fmt.Println("s1", s1)
	// fmt.Println("s2", s2)
	// fmt.Println("s3", s3)
	// fmt.Println("z", z)
	// fmt.Println("zmu", zmu)

	var vHx fr.Element
	vHx.Mul(&hx, &vanishingX)
	result.Sub(&result, &vHx)

	var vanishingY fr.Element
	vanishingY.Exp(beta, big.NewInt(int64(vk.SizeY)))
	vanishingY.Sub(&vanishingY, &one)

	var vHy fr.Element
	vHy.Mul(&hy, &vanishingY)
	result.Sub(&result, &vHy)

	// if result != 0 return error
	if !result.IsZero() {
		return fmt.Errorf("constraints on Y are not satisfied: got %s, want 0", result.String())
	}
	return nil
}
