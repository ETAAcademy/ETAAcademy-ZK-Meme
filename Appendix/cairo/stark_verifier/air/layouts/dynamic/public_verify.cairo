from starkware.cairo.common.math import assert_le, assert_nn, assert_nn_le, safe_div
from starkware.cairo.common.pow import pow
from starkware.cairo.common.registers import get_label_location
from starkware.cairo.stark_verifier.air.layout import AirWithLayout
from starkware.cairo.stark_verifier.air.layouts.dynamic.autogenerated import (
    CPU_COMPONENT_HEIGHT,
    LAYOUT_CODE,
    PUBLIC_MEMORY_FRACTION,
    DynamicParams,
    check_asserts,
)
from starkware.cairo.stark_verifier.air.public_input import PublicInput, SegmentInfo
from starkware.cairo.stark_verifier.air.public_memory import AddrValue
from starkware.cairo.stark_verifier.core.domains import StarkDomains

const MAX_LOG_N_STEPS = 50;
const MAX_RANGE_CHECK = 2 ** 16 - 1;

namespace segments {
    const PROGRAM = 0;
    const EXECUTION = 1;
    const OUTPUT = 2;
    const PEDERSEN = 3;
    const RANGE_CHECK = 4;
    const ECDSA = 5;
    const BITWISE = 6;
    const EC_OP = 7;
    const KECCAK = 8;
    const POSEIDON = 9;
    const RANGE_CHECK96 = 10;
    const ADD_MOD = 11;
    const MUL_MOD = 12;
    const N_SEGMENTS = 13;
}

const INITIAL_PC = 1;
const FINAL_PC = INITIAL_PC + 4;

// Returns a zero-terminated list of builtins supported by this layout.
func get_layout_builtins() -> (n_builtins: felt, builtins: felt*) {
    let (builtins_address) = get_label_location(data);
    let n_builtins = 11;
    assert builtins_address[n_builtins] = 0;
    return (n_builtins=n_builtins, builtins=builtins_address);

    data:
    dw 'output';
    dw 'pedersen';
    dw 'range_check';
    dw 'ecdsa';
    dw 'bitwise';
    dw 'ec_op';
    dw 'keccak';
    dw 'poseidon';
    dw 'range_check96';
    dw 'add_mod';
    dw 'mul_mod';
    dw 0;
}

// Verifies that the public input represents a valid Cairo statement: there exists a memory
// assignment and a valid corresponding program trace satisfying the public memory requirements.
//
// This function verifies that:
// * The 16-bit range-checks are properly configured
//   (0 <= range_check_min <= range_check_max < 2^16).
// * The layout is valid.
// * The segments for the builtins do not exceed their maximum length (thus,
//   when these builtins are properly used in the program, they will function correctly).
//
// This function DOES NOT verify anything regarding the public memory. This should be verified
// by the user. In particular, it is not validated that:
// * [initial_fp - 2] = initial_fp, which is required to guarantee the "safe call"
//   feature (that is, all "call" instructions will return, even if the called function is
//   malicious). It guarantees that it's not possible to create a cycle in the call stack.
// * the arguments and return values for main() are properly set (e.g., the segment
//   pointers).
// * the requested program is loaded, starting from initial_pc.
// * final_pc points to the end of the program.
// * program output is valid in any sense.
// * The continuous pages are consistent. See public_memory.cairo.
func public_input_validate{range_check_ptr}(
    air: AirWithLayout*, public_input: PublicInput*, stark_domains: StarkDomains*
) {
    alloc_locals;

    let dynamic_params = cast(public_input.dynamic_params, DynamicParams*);
    assert_nn_le(public_input.log_n_steps, MAX_LOG_N_STEPS);
    let (local n_steps) = pow(2, public_input.log_n_steps);
    tempvar trace_length = stark_domains.trace_domain_size;
    assert n_steps * CPU_COMPONENT_HEIGHT * dynamic_params.cpu_component_step = trace_length;

    assert_le(0, public_input.range_check_min);
    assert_le(public_input.range_check_min, public_input.range_check_max);
    assert_le(public_input.range_check_max, MAX_RANGE_CHECK);

    assert public_input.layout = LAYOUT_CODE;

    // Segments.
    let n_output_uses = (
        public_input.segments[segments.OUTPUT].stop_ptr -
        public_input.segments[segments.OUTPUT].begin_addr
    );
    assert_nn(n_output_uses);

    assert public_input.n_segments = segments.N_SEGMENTS;

    local n_pedersen_copies;
    if (dynamic_params.uses_pedersen_builtin == 0) {
        assert n_pedersen_copies = 0;
    } else {
        assert n_pedersen_copies = trace_length / dynamic_params.pedersen_builtin_row_ratio;
    }
    let n_pedersen_uses = (
        public_input.segments[segments.PEDERSEN].stop_ptr -
        public_input.segments[segments.PEDERSEN].begin_addr
    ) / 3;
    // Note that the following call implies that trace_length is divisible by
    // dynamic_params.pedersen_builtin_row_ratio
    // and that stop_ptr - begin_addr is divisible by 3.
    assert_nn_le(n_pedersen_uses, n_pedersen_copies);

    local n_range_check_copies;
    if (dynamic_params.uses_range_check_builtin == 0) {
        assert n_range_check_copies = 0;
    } else {
        assert n_range_check_copies = trace_length / dynamic_params.range_check_builtin_row_ratio;
    }
    let n_range_check_uses = (
        public_input.segments[segments.RANGE_CHECK].stop_ptr -
        public_input.segments[segments.RANGE_CHECK].begin_addr
    );
    // Note that the following call implies that trace_length is divisible by
    // dynamic_params.range_check_builtin_row_ratio.
    assert_nn_le(n_range_check_uses, n_range_check_copies);

    local n_ecdsa_copies;
    if (dynamic_params.uses_ecdsa_builtin == 0) {
        assert n_ecdsa_copies = 0;
    } else {
        assert n_ecdsa_copies = trace_length / dynamic_params.ecdsa_builtin_row_ratio;
    }
    let n_ecdsa_uses = (
        public_input.segments[segments.ECDSA].stop_ptr -
        public_input.segments[segments.ECDSA].begin_addr
    ) / 2;
    // Note that the following call implies that trace_length is divisible by
    // dynamic_params.ecdsa_builtin_row_ratio
    // and that stop_ptr - begin_addr is divisible by 2.
    assert_nn_le(n_ecdsa_uses, n_ecdsa_copies);

    local n_bitwise_copies;
    if (dynamic_params.uses_bitwise_builtin == 0) {
        assert n_bitwise_copies = 0;
    } else {
        assert n_bitwise_copies = trace_length / dynamic_params.bitwise__row_ratio;
    }
    let n_bitwise_uses = (
        public_input.segments[segments.BITWISE].stop_ptr -
        public_input.segments[segments.BITWISE].begin_addr
    ) / 5;
    // Note that the following call implies that trace_length is divisible by
    // dynamic_params.bitwise__row_ratio
    // and that stop_ptr - begin_addr is divisible by 5.
    assert_nn_le(n_bitwise_uses, n_bitwise_copies);

    local n_ec_op_copies;
    if (dynamic_params.uses_ec_op_builtin == 0) {
        assert n_ec_op_copies = 0;
    } else {
        assert n_ec_op_copies = trace_length / dynamic_params.ec_op_builtin_row_ratio;
    }
    let n_ec_op_uses = (
        public_input.segments[segments.EC_OP].stop_ptr -
        public_input.segments[segments.EC_OP].begin_addr
    ) / 7;
    // Note that the following call implies that trace_length is divisible by
    // dynamic_params.ec_op_builtin_row_ratio
    // and that stop_ptr - begin_addr is divisible by 7.
    assert_nn_le(n_ec_op_uses, n_ec_op_copies);

    local n_keccak_copies;
    if (dynamic_params.uses_keccak_builtin == 0) {
        assert n_keccak_copies = 0;
    } else {
        assert n_keccak_copies = trace_length / dynamic_params.keccak__row_ratio;
    }
    let n_keccak_uses = (
        public_input.segments[segments.KECCAK].stop_ptr -
        public_input.segments[segments.KECCAK].begin_addr
    ) / 16;
    // Note that the following call implies that trace_length is divisible by
    // dynamic_params.keccak__row_ratio
    // and that stop_ptr - begin_addr is divisible by 16.
    assert_nn_le(n_keccak_uses, n_keccak_copies);

    local n_poseidon_copies;
    if (dynamic_params.uses_poseidon_builtin == 0) {
        assert n_poseidon_copies = 0;
    } else {
        assert n_poseidon_copies = trace_length / dynamic_params.poseidon__row_ratio;
    }
    let n_poseidon_uses = (
        public_input.segments[segments.POSEIDON].stop_ptr -
        public_input.segments[segments.POSEIDON].begin_addr
    ) / 6;
    // Note that the following call implies that trace_length is divisible by
    // dynamic_params.poseidon__row_ratio
    // and that stop_ptr - begin_addr is divisible by 6.
    assert_nn_le(n_poseidon_uses, n_poseidon_copies);

    local n_range_check96_copies;
    if (dynamic_params.uses_range_check96_builtin == 0) {
        assert n_range_check96_copies = 0;
    } else {
        assert n_range_check96_copies = trace_length /
            dynamic_params.range_check96_builtin_row_ratio;
    }
    let n_range_check96_uses = (
        public_input.segments[segments.RANGE_CHECK96].stop_ptr -
        public_input.segments[segments.RANGE_CHECK96].begin_addr
    );
    // Note that the following call implies that trace_length is divisible by
    // dynamic_params.range_check96_builtin_row_ratio.
    assert_nn_le(n_range_check96_uses, n_range_check96_copies);

    local n_add_mod_copies;
    if (dynamic_params.uses_add_mod_builtin == 0) {
        assert n_add_mod_copies = 0;
    } else {
        assert n_add_mod_copies = trace_length / dynamic_params.add_mod__row_ratio;
    }
    let n_add_mod_uses = (
        public_input.segments[segments.ADD_MOD].stop_ptr -
        public_input.segments[segments.ADD_MOD].begin_addr
    ) / 7;
    // Note that the following call implies that trace_length is divisible by
    // dynamic_params.add_mod__row_ratio
    // and that stop_ptr - begin_addr is divisible by 7.
    assert_nn_le(n_add_mod_uses, n_add_mod_copies);

    local n_mul_mod_copies;
    if (dynamic_params.uses_mul_mod_builtin == 0) {
        assert n_mul_mod_copies = 0;
    } else {
        assert n_mul_mod_copies = trace_length / dynamic_params.mul_mod__row_ratio;
    }
    let n_mul_mod_uses = (
        public_input.segments[segments.MUL_MOD].stop_ptr -
        public_input.segments[segments.MUL_MOD].begin_addr
    ) / 7;
    // Note that the following call implies that trace_length is divisible by
    // dynamic_params.mul_mod__row_ratio
    // and that stop_ptr - begin_addr is divisible by 7.
    assert_nn_le(n_mul_mod_uses, n_mul_mod_copies);

    let n_memory_units = trace_length / dynamic_params.memory_units_row_ratio;
    assert_nn_le(
        4 * n_steps + safe_div(n_memory_units, PUBLIC_MEMORY_FRACTION) + 3 * n_pedersen_copies + 1 *
        n_range_check_copies + 2 * n_ecdsa_copies + 5 * n_bitwise_copies + 7 * n_ec_op_copies + 16 *
        n_keccak_copies + 6 * n_poseidon_copies + 1 * n_range_check96_copies + 7 *
        n_add_mod_copies + 7 * n_mul_mod_copies,
        n_memory_units,
    );

    let n_rc_units = trace_length / dynamic_params.range_check_units_row_ratio;
    assert_nn_le(
        3 * n_steps + 8 * n_range_check_copies + 6 * n_range_check96_copies + 66 * n_mul_mod_copies,
        n_rc_units,
    );

    let n_diluted_units = trace_length / dynamic_params.diluted_units_row_ratio;
    assert_nn_le(68 * n_bitwise_copies + 16384 * n_keccak_copies, n_diluted_units);

    if (dynamic_params.uses_keccak_builtin != 0) {
        assert_nn_le(16, n_keccak_copies);
        tempvar range_check_ptr = range_check_ptr;
    } else {
        tempvar range_check_ptr = range_check_ptr;
    }

    check_asserts(dynamic_params=dynamic_params, stark_domains=stark_domains);

    return ();
}
