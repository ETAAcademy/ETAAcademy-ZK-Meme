from starkware.cairo.common.cairo_builtins import BitwiseBuiltin, PoseidonBuiltin
from starkware.cairo.common.hash import HashBuiltin
from starkware.cairo.common.registers import get_label_location
from starkware.cairo.stark_verifier.air.layout import AirWithDynamicLayout, DynamicLayout, Layout
from starkware.cairo.stark_verifier.air.layouts.dynamic.autogenerated import (
    CONSTRAINT_DEGREE,
    MASK_SIZE,
    N_CONSTRAINTS,
    N_DYNAMIC_PARAMS,
    DynamicParams,
    eval_oods_polynomial,
)
from starkware.cairo.stark_verifier.air.layouts.dynamic.composition import (
    traces_eval_composition_polynomial,
)
from starkware.cairo.stark_verifier.air.layouts.dynamic.global_values import InteractionElements
from starkware.cairo.stark_verifier.air.layouts.dynamic.public_verify import public_input_validate
from starkware.cairo.stark_verifier.air.oods import eval_oods_boundary_poly_at_points
from starkware.cairo.stark_verifier.air.public_input import PublicInput, public_input_hash
from starkware.cairo.stark_verifier.air.traces import (
    traces_commit,
    traces_config_validate,
    traces_decommit,
)
from starkware.cairo.stark_verifier.core.air_interface import AirInstance
from starkware.cairo.stark_verifier.core.stark import StarkProof, verify_stark_proof

// Builds an AirInstance object to use for STARK verification. See AirInstance at
// air_interface.cairo.
func build_dynamic_air{range_check_ptr}(dynamic_params: felt*) -> (air: AirWithDynamicLayout*) {
    let dynamic_params_ = cast(dynamic_params, DynamicParams*);
    let (arg_public_input_hash) = get_label_location(public_input_hash);
    let (arg_public_input_validate) = get_label_location(public_input_validate);
    let (arg_traces_config_validate) = get_label_location(traces_config_validate);
    let (arg_traces_commit) = get_label_location(traces_commit);
    let (arg_traces_decommit) = get_label_location(traces_decommit);
    let (arg_traces_eval_composition_polynomial) = get_label_location(
        traces_eval_composition_polynomial
    );
    let (arg_eval_oods_boundary_poly_at_points) = get_label_location(
        eval_oods_boundary_poly_at_points
    );
    let (arg_eval_oods_polynomial) = get_label_location(eval_oods_polynomial);

    tempvar air = new AirWithDynamicLayout(
        air=AirInstance(
            public_input_hash=arg_public_input_hash,
            public_input_validate=arg_public_input_validate,
            traces_config_validate=arg_traces_config_validate,
            traces_commit=arg_traces_commit,
            traces_decommit=arg_traces_decommit,
            traces_eval_composition_polynomial=arg_traces_eval_composition_polynomial,
            eval_oods_boundary_poly_at_points=arg_eval_oods_boundary_poly_at_points,
            n_dynamic_params=N_DYNAMIC_PARAMS,
            n_constraints=N_CONSTRAINTS,
            constraint_degree=CONSTRAINT_DEGREE,
            mask_size=MASK_SIZE,
        ),
        layout=DynamicLayout(
            layout=Layout(
                eval_oods_polynomial=arg_eval_oods_polynomial,
                n_original_columns=dynamic_params_.num_columns_first,
                n_interaction_columns=dynamic_params_.num_columns_second,
                n_interaction_elements=InteractionElements.SIZE,
            ),
            dynamic_params=dynamic_params,
        ),
    );
    return (air=air);
}

func verify_proof{
    range_check_ptr,
    pedersen_ptr: HashBuiltin*,
    bitwise_ptr: BitwiseBuiltin*,
    poseidon_ptr: PoseidonBuiltin*,
}(proof: StarkProof*, security_bits: felt) -> () {
    let public_input = cast(proof.public_input, PublicInput*);
    let (air) = build_dynamic_air(public_input.dynamic_params);
    return verify_stark_proof(air=&air.air, proof=proof, security_bits=security_bits);
}
