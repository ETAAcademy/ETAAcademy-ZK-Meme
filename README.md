# ETAAcademy-ZK-Meme: Learn ZK in One Sentence

ETA Academy is a research community dedicated to zero-knowledge proofs (zk). Fueled by a daily Twitter check-in summarizing one zk learning point, the ETAcademy-ZK-Meme series was born. With the initial 50 entries, we aim for this meme collection to become everyone's go-to pocket guide for understanding zk quickly. Join the movement and help us make zk accessible! [twitter](https://twitter.com/pwhattie/status/1744001346314134003)

Here are some ways to participate in the ETAAcademy-ZK-Meme series:

- Create your own memes and share them on Twitter with the hashtag #ETAcademyZKMeme.
- Translate the memes into other languages.
- Use the memes to teach others about zk.

By participating in the series, you can help to make zk more accessible to everyone.

Authors: [Eta](https://twitter.com/pwhattie), looking forward to your joining

## A

Account Abstract: EIP4337 contracts with EOAs: UserOperation(Calls)â†’Bundler(Miner, Relayer)â†’EntryPointâ†’Wallet(Validate, Paymaster, execute)
EIP3074 EOAs with contracts:AUTH&AUTHCALL for(v, r, s), commit & call
EIP2938:rlp([nonce, target, data]), PAYGAS, NONCE.

Arithmetic circuits, using â• and âœ–ï¸ gates, asserts inputs instance(x) and witness(w) from a finite field F, C(x, w) = y. R1CS constraint system, a circuit-based interactive proof, states multiplication or gates for left input âŠ— right input = output, L Ã— C âŠ— RÃ—C = O Ã—C.ğŸ¦•

## B

Bilinear pairing e:G1Ã—G2â†’Gt for mult
if elliptic curves $G_1, G_2,G_t$ are isomorphic, cyclic group, G=G1=G2 , generator g, prime p, a,bâˆˆFp finite field, then $e(g^a,g^b)=e(g,g)^{ab}, e(g,g)î€ â‰ e_{Gt},$ addition $e(ag,bg)=e(g,g)^{ab},$ and key exchange $e(g^b,g^c)^a=g^{abc}.$

Block ciphers merge the plaintext and ciphertext spaces into a block space. They serve not only for encryption but also as fundamental components in constructing various cryptographic tools like stream ciphers, hash functions, message authentication codes (MACs), and others.

## C

CBC mode utilizes a PRP to achieve CPA security by XORing each plaintext block with the previous ciphertext block before encryption, employing an initialization vector (IV) to ensure security, and allowing parallel decryption.

Chinese Remainder states that coprime integers $n_1, ..., n_m âˆˆ N,$ with their product $n = Î _{i=1}^m n_i,$ and any integers $a_1, ...,a_m âˆˆ Z,$ there exists a unique residue x of a modulo n, a and (a mod $n_1,$ ..., a mod $n_m)$ break larger problem into smaller one.

CPA security, akin to semantic security, addresses chosen plaintext attacks, but in CPA, attackers can query the challenger many times, where each query involves encrypting either m_0 or m_1, maintaining equal-length plaintexts but allowing variation across queries.

CTR employs a pseudo-random function, achieves CPA security by XOR the key stream generated from an IV with plaintext during encryption and decryption.

Cyclic Group or Monogenous Group is a group generated by a single elementğŸ¬ï¼Œ $<ğŸ¬> = { ğŸ¬^k | k âˆˆ Z },$ and the more such ğŸ¬, the more powerful properties <ğŸ¬>.

## D

Direct Product, ğŸ¬Ã—ğŸ¤ <=> ğŸ±, is an operation that takes two groups G ğŸ¬ and H ğŸ¤and constructs a new group ğŸ±, usually denoted G Ã— H, in turn, which looks like a group ğŸ± has many ğŸ¬sub.groups ğŸ¤.

## E

[Elliptic Curve](https://github.com/ETAAcademy/ETAAcademy-ZK-Meme/blob/main/01_Ouick_Read/01_Elliptic_Curves.md) : $y^2 = x^3 + ax + b, a,b âˆˆ F,$ $char(F) â‰  2,3,$ and $â–³ = 4a^3 + 27b^2 â‰  0.$ => The points (x, y) in the curve known as P, Q, or R, and the infinity point O, forms a set E = {(x, y) | $y^2 = x^3$ + ax + b} âˆª {O} => E & add operation yields a group (E, +).

Elliptic curve addition: For $P=(x_1, y_1),$ $Q=(x_2, y 2),$ Pâ‰ Qï¼ŒP=Q, Both have intersection points, O or R: 1. Geometric â•: P + Q = -O or R: P+Q+O=Oâ‡’P+Q=O, P+Q+R=Oâ‡’P+Q=âˆ’R. 2. Coordinate â•ï¼šO= 0ï¼› $R (x3,âˆ’y3)=(Î»2âˆ’x1âˆ’x2,âˆ’Î»3+(x1+x2)Î»âˆ’c),$ if the line y=Î»x+c.

## F

Fflonk & Dan: Fflonk changes single-point polynomials into a polynomial multi-point calculation, where k= 1, Dan verifies pairings on polynomials, not points, by three double-point operations.

Fiat-Shamir: Non-interactive Fiat, compared to interactive zk proof, hash c to for randomization, i.e. A: $v âˆˆ Z^*_p,$ $t = g^v$ mod p â‡’ B: c = H(g, y, t) â‡’ A: r = v - cx mod {Ï†(p)}, â‡’ B: $t â‰¡ g^rg^c,$ as $g^{r}y^{c} â‰¡ g^{v-cx}g^{xc} â‰¡ g^{v} â‰¡ t$ and ${ g^{Ï† (p)} â‰¡ 1}ğŸ›¸$

Fields(F) extend the concepts of Groups (add, sub) and Rings (add, sub, mult) by introducing divisionï¼Œi.e., non-zero element has a mult inverse $a^{-1}.$ The characteristic of a field is the order of the additive identity, usually 0 or a prime number.

Finite Fields & Point Compress (PC): 1) Elliptic curves $(F_p),$ scattered points, have coordinate from F_p and â•, f(x), and â–³ modulo p, $|E(F_p)| â‰¤ 2p + 1;$ 2) Pc trades off space for time for expansion issue of elliptic cryptography, stores (x, y) as (x, y mod 2).ğŸŒ¹

F/K, like F and F[x], means F is the field extension of K, if K is a subfield of F, with f(x) whose coefficients from K, if a âˆˆ F. All such f(x) forms an ideal J generated by the minimal polynomial f(x), or the monic, irreducible g(x) with its root "a".

Finite Field
The finite field GF(p), or $F_p,$ is characterized by having a prime number of elements and a characteristic of p. Fields of the same order are isomorphic, and its extension, denoted as $F_p^n,$ represents a field of order $p^n.ğŸ¡ğŸ¦$

## G

Goldwasser-Micali(GM): Legendre $x/p = x/q = -1,$ Jacobi $x/N = (x/p)(x/q) = 1,$ public key (x, N), private key(p, q) => quadratic non-residue encryption $c_i = r^2x$ mod N => quadratic residue decryption $c_p^{(p-1)/2}$ = 1 mod p, $c_q^{(q-1)/2}$ = 1 mod q.

Groth16: upgrades Pinocchio, also verifies bilinearpairing e( \[A\]1 , \[B\]2 ) = e(Î± $G_1$, Î² $G_2$ ) â‹… e ( $âˆ‘^l_{i=0}$ $\frac{Î²u \* i(x)+Î±v_i(x)+w_i(x)}{Î³} G_1, Î³G_2$ ) â‹… e( $[C]_1,$ $Î´G_2$ ) by QAP, $âˆ‘^m \* {i=0}a \* iu_i(x) âˆ‘^m \* {i=0} a \* iv_i(x) = âˆ‘^m \* {i=0}a_iÏ‰_i(x) + h(x)z(x),$ but less constraints.

## H

Halo2 like UltralPlonk, creates final-poly by Plookup, vanishing, multipoint opening argument, p(X) = q'(X) + \[x_4\] $\Sigma^{n \* q-1}$ \* ${i=0}[x^i_4]q \* i(X)$ , but verified by IPAs.

Halo2 Fibonacci API utilizes a constraint system with columns for advice, instance, fixed, and selector. It's optimized by regions to implement the Fibonacci trait through configuration, chip, and circuit, e.g. f(n) = f(n-1) + f(n-2).

Homo and Iso: Similar to group homomorphisms (addition) but with multiplication, ring homomorphisms has a kernel, the inverse image of 0. The Isomorphism asserts that two rings share identical structures with different element names, e.g. the quotient ring R/Ker(f) â‰… Im(f).

## I

Ideals (I) and Quotient Rings (R/I) are like normal subgroups with Absorption Law and quotient groups. ğŸ£(I) include {0}, R itself, and principal ideals (a) = {ab | b âˆˆ R}, while ğŸ¥R/I has add (a+I)+(b+I)=a+b+I, mult (a+I)(b+I)=ab+I, with a congruence relation aâ‰¡b(mod I).

Infinite & Singular: 1. Elliptic curve is an affine equation, $(x, y) âˆˆ A^2(F)$ =>projective $(X, Y, Z) âˆˆ P^2(F).$ If Z = 0, they are infinite point O, & line $P^1(F).$ 2. If $â–³ = 4a^3 + 27b^2 = 0,$ <=> not smooth <=> repeated roots, singular points lie on the x-axis.

IPAs, using elliptic curve add and mult to verify and not to reveal the polynomial $P(x) = Î£_ic_ix^is, C(P) = Î£_ic_ig_i,$ with generator 'g', coefficients 'c', random a, aggregate each cg into a larger one until $c'_0 g'_0 = C', i.e. C' = C + a^2L + {R}/{a^2}.ğŸ›¸$

Modified IPAs have generators on elliptic curves by hashing system parameters(SP) , $G_i= hash(G,i, SP), i=1, ...,n ,$ and vector inner product $z= <a^â†’, b^â†’>=z+x^{-2}l_z + x^2f_z,$ rather than multi-party secure computation and quotient polynomial commitment of KZG.

Isogeny, a group surjective homomorphism of elliptic curves, Î¦: E(K) â†’ E'(K), maps the infinite point of E(K) to that of E'(K), Î¦(O) = O'. Endomorphism is an isogeny of an elliptic curve to itself, while automorphism is isogeny, endomorphism and isomorphism.

## K

$K^{(n)},$ the n-th cyclotomic field over field K, contains K and the roots of polynomials $Q_n(x)=x^n-e=(x-x_1)...(x -x_i)...(x-x_n)=\Pi^n_{s=1}(x - a^s),$ i.e., the splitting field over K. The set E(n) formed by these roots forms a cyclic group for finite fields.

KZG obtains f(x): $[f(S)] = [a_0S^0 + a_1S^1 + a_2S^2] = a_0[S^0] + a_1[S^1] + a_2[S^2] = a_i[S^i]$ by Lagrange interpolation, constructs and transfroms $h(x) = {f(x)-f(z)}/{x-z}$ into bilinear pairing to verify S instead of the f(x), $e([S-z], [h(S)]) = e([f(S)]-[f(z)], [1]).$

## M

Merkle commitment: By computing the Merkle root' := Merkle(c, path(c)) based on the node and its verification path (c, path(c)), where root' = root, it ensures that c exists in the Merkle tree.

[Modular blockchains](https://github.com/ETAAcademy/ETAAcademy-ZK-Meme/edit/main/README.md#:~:text=05_Modular_Blockchains) organize tasks into separate layers or modules, like consensus, execution, data availability, and settlement, offering enhanced flexibility and scalability compared to monolithic blockchains.

## P

Pinocchio: 1) create elliptic curve generator for all operand to simplify constraints, $g_l  =g^{Ïl};$ 2) let verifier & prover compute together $L(x)=L_v(x)+L_p(x);$ 3) obfuscate &random for zk proof $(L(s) + Î´_l) Â·(R(s) + Î´_r) - (O(s) + Î´_o) =t(s)Â·(h(s) + â–³).$

PLONK: It creates polynomials by Gate & Linear Constraints(â•, âœ–ï¸, &), not R1CS, $Q_L(X)â‹…a(X)+Q_R(X)â‹…b(X)+Q_o(X)â‹…c(X)+Q_M(X)â‹…a(X)â‹…b(X)+Qc(X)=Z(x)â‹…H(x), f(iâ‹…G)=f(iâ‹…G)+ Î²â‹…i+Î³,g(iâ‹…G)=g(iâ‹…G)+Î²â‹…Ïƒ(i)+Î³,$ Aggregation proofs to a Bilinear $e(xâ‹…G1, yâ‹…G2)=e(jâ‹… G1, kâ‹…G2).$

Plookup coordinate accumulators prove polynomial âŠ‚ and/or table for gate constraints; i.e., given $fâˆˆF^n,tâˆˆF^d, sâˆˆF^{n+d}, F(Î², Î³)â‰”(1+Î²)^nâ‹…âˆ_{iâˆˆ[n]}(Î³+fi)âˆ_{iâˆˆ[dâˆ’1]}(Î³(1 + Î²) + t_i + Î² â‹… t_{i+1}), G(Î², Î³);$ then $Z(g^n+1) = 1 => F â‰¡ G => f âŠ‚ t, s = (f, t).$ â¤ï¸ğŸ›¸

PRF resembles a block cipher PRP, where distinguishing between randomly chosen and key-based functions is central, with PRP serving as a pseudo-random permutation akin to PRF's deterministic function aiming for randomness with a randomly generated key.

Primitive f(x) over F_q is the minimal polynomial of a primitive element in the field $F_q[X]$ that f(x) with non-zero a constant term must be monic, $ord(f(x)) = q^m - 1,$ where the polynomial order ord(f(x)) is the smallest positive integer n for $f(x)|(x^n-e).$

Primitive Root & Discrete Logarithm: An integer g ğŸ³ is a primitive root (mod n) that generates every element for a group $Z_n^*,$ So gğŸ³ may serve as a base $ğŸ§œâ€â™€ï¸g^x$ â‰¡ a (mod n) for a discrete logarithm x = $log_g^a$ and as a generator ğŸ¬for a cyclic group <ğŸ¬> = { $ğŸ¬^k$ | k âˆˆ Z }.

Polynomial P(x) = $Î£_{j=0}^{n}{a_jx^j}$ is a sum of terms with the highest power of deg(P), its coefficient Lc(P), common add and mult, while factoring used to find roots (x for P(x)=0) construct Li(x) for Lagrange interpolation P(x) = $Î£*{i=0}^n y_i â‹…L_i(x).$

Polynomial Constraints, to increase randomness and prevent proving forgery, use v, Î±ï¼ŒÎ², Î³ to constrain p(x)=L(x) â‹… R(x) - O(x) in terms of value (0, 1), transforming e.g. O â‹…R = L, consistency $v_{L,i} = v_{R,i} = v_{o,i} = v_{ Î²,i}ï¼Œ iâˆˆ{1,â€¦,n}$ and constants.

Polynomial ring R[x] has a and x from its base ring R, i.e., if R is a commutative or integral ring, the R[x] inherits these properties. But a field F[x] is different, e.g. $Q(x) = a_n^{-1} P(x)$ is a monic polynomial if P(x) âˆˆ F[x] with $Lc(P) = a_n.$

[Pseudo-random](https://github.com/ETAAcademy/ETAAcademy-ZK-Meme/blob/main/01_Ouick_Read/07_PRG.md) sequences come in various forms, but in cryptography, a pseudo-random sequence is one that cannot be distinguished from a genuinely random sequence, Adv := | Pr[W_0] - Pr[W_1]|.

## Q

QAP, the polynomial form of R1CS, relies on li (x) and ci, public instance and private witness to produces: $L(x)=Î£^n_{i=1}c_iÃ—l_i(x),$ similar R(x), O(x),and then $p(x)=L(x) â‹… R(x)-O(x)=(Î£^n_{i=1}c_i â‹… l_i(x))Ã—(Î£^n_{i=1}c_i â‹… r_i(x))-(Î£^n_{i=1}c_i â‹… o_i(x))=0 .ğŸŒğŸ¥¤ğŸ‡$

Quadratic Residues:
Euler's Criterion asserts that for an odd prime p and gcd(a, p) = 1, it holds that $a^{(p-1)/2} â‰¡a/p (mod p).$ When Legendre symbol $a/p = 1$ a is a quadratic residue modulo n,. $x^2 â‰¡ a \pmod{n},$ having $(pâˆ’1)/2$ quadratic residues p.ğŸ£

## R

Ring simply seen as a group has two binary operations, â• and âœ–ï¸, e.g. the rings of integers Z and integers modulo n Zn are also groups. Now for a ring's interesting feature: based on Distributive Law, (-ğŸ¬)ğŸ¶ = -(ğŸ¬ğŸ¶) = ğŸ¬(-ğŸ¶) = -(-ğŸ¬)(-ğŸ¶), if ğŸ¬, ğŸ¶ âˆˆ R ğŸª.

## S

SHA256 table generates 256-bit random zk proof by 8+64 constants, padding Delta+1+k+64 mod 512 = 0, expansion & compression $MapH_i:= Map(H_{i-1}, M_i),$ which constrains boolean to spread lookup + arithmetic circuit (Plonk), (x, x') âˆˆ Table, x' = spread (x).

SHA256 constraints have expansion of $Wi=Ïƒ_1(W_{iâˆ’2})ç”°W_{iâˆ’7}ç”°Ïƒ_0(W_{iâˆ’15})ç”°W_{iâˆ’16},$ spread of modular $aç”°b =c,$ functions of $Ma(A,B,C)=(Aâˆ§B)âŠ•(Aâˆ§C)âŠ•(Bâˆ§C), Ch(E,F,G), âˆ‘_0(A)=(A>>>2)âŠ•(A>>>13)âŠ•(A>>>22), âˆ‘_1(E)$ constraints to algebraic operation.

Simple extension K(a) is the smallest extension field of subfield K and â€œaâ€, the homomorphic image to be an isomorphism with the quotient ring ofits irreducible polynomial g(x), $Im(t) â‰… K[X]/Ker(t) â‡’ Im(t) â‰… K[X]/ (g(x)) â‡’ K(a) â‰… K[X]/ (g(x)).$

Splitting field Lï¼Œas simple extensions added by elements, is the minimal extension of field K and the roots of polynomial factors $f(x) = b(x-a_1)(x-a_2)...(x-a_m).$ The finite field of $p^n$ is isomorphic to its unique splitting field of $x^{p^n}âˆ’x$ over $Z_p.$

[Stream Ciphers](https://github.com/ETAAcademy/ETAAcademy-ZK-Meme/blob/main/01_Ouick_Read/03_Stream_Cipher.md) use a PRG to generate a longer key from a shorter one. This extended key is then XORed with the plaintext to produce ciphertext, or with ciphertext to retrieve the original plaintext, $G: {0, 1}^s$ â†’ ${0, 1}^n$, $K={0,1}^s$, $M=C={0, 1}^n$, E(k, m): G(k)âŠ•m = c, D(k, c): G(k)âŠ•c=m, (E, D) is a stream cipher defined on (K, M, C).

## T

Trace (Tr) and Norm (N) are â• and âœ–ï¸ mappings from extension field to its baseï¼Œa âˆˆ F = $F_q^m,$ K= $F_q,$ $Tr_{F/K}(a)$ = $a + a^q + ... + a^{q^{m-1}};$ Compute: minimal polynomial => characteristic polynomial $g(x)^{ m/d}$ => $Tr_{F/K}(a)$ = $-a_{m-1},$ $N_{F/K}(a)=(-1)^ma_0.$

Tweedledum & Amortization take parallel computation on polynomial commitments and value, add random and secret a for Sigma zk proof, C':=A' +z'U+r'H = U+r'H = $A+x^{-2}L_a+x^2R_a$ + $z+x^{-2}l_z+x^2r_zU$ + $(r+x^{-2}r_L+x^2r_H)H$ = $C+x^{-2}L+x^{-2}R;$ $cÂ·C +R = z_1G+z_1bÂ·U+z_2Â·H.$

## U

UltraPlonk: PK of Plonk KZG (or Dan + Fflonk) PK, Plookup table T*{1,i}, T*{2,i},T*{3,i},i=1,..,n, circuit to create quotient polynomial, verify bilinear pairing by VK on ETH, e(WÎ·(x)1 + uÂ· W{Ï‰Î·}(x) Â· 1, Ï‡2) = e(Î·Â· W * Î·(x)1+uÎ·Ï‰Â·W{Ï‰Î·}x1 + F1-E1,l2).

## Z

ZK-EVMs scale ETH by improving verification or EVM compatibility from ETH-equiv(PSE, Taiko), EVM-equiv(Scroll, Polygon), Almost EVM-equiv(Gas adjust), to language-equiv(Starkware, zkSync), e.g. Gethâ†’Traceâ†’Roller(zkEVM Aggr. circuit â†’Aggr. proof) â†’ L1 contract.

zk Homomorphism in projective coordinates: For Î¦: E(K) â†’ E'(K), E(k) be $y^2 = x^3 + ax + b,$ $f(x) = x^3 + ax + b,$ P = (x, y) âˆˆ E(K), the standard form is $Î¦(x, y) = ({u(x)}/{v(x)}, {s(x)}/{t(x)}y),$ with divisor relations: $v^3(x)|t^2(x)$ and $t^2(x)|v^3(x)f(x).$

ZK Proof: For m = 0 <=> z = r, m = 1 <=> z = rx, validators verifie the quadratic residue directly by $c Â· x^{2b} â‰¡ z^2$ mod $N,$ compared to the GM algorithm. The zk proof ensures validators succesfully verify z when m = 0 even if they doesn't know x.

[zkStark](https://github.com/ETAAcademy/ETAAcademy-ZK-Meme/blob/main/README.md#:~:text=07_PRG.md-,08_zkStark,-.md): RS Codes improves 2^n Trace poly on AIR, not circuit PK & VK, immune to for loops. Unchanged order blowup root $2^kN$ poly, hash Poseidon2, combined by quotient poly, yields $DEEP(x) = a_0{s_0(x) - s_0(z)}/{x-z} + a_1{s_1(x) - s_1(z)}/{x-z} + a_2{CP(x)-CP(z)}/{x-z}.$ For FRI, along with folding n and Merkle commitments of verified by grinding factors like Pow.

zkStark AIR & ALI convert arithmetic & boundary constraints into divisibility over a finite field that AIR use quotient polynomials verify trace $P={P_1(X^â†’, Y^â†’),...,P_s(X^â†’,Y^â†’)}$ and ALI diminish the time and space complexity to reduce polynomials into one as FRI.

zkStark Fibonacci: F(X,Y)=Z, like zkSnark's Sigma H=wG, trace T to satisfy transition and boundary constraints by quotient polynomials $C_0(x) = {P_1(x+1) - (P_0(x)+P_1(x))} / {âˆ‘^i_{0,...,n-1}(x-i)}, C_1(x), C_2(x)={P_0(x)-X}/{x-0}, C_3(x)$ combined into one f(x) for FRI.

zkStark FRI reduces a polynomial of degree d to two merged into one by random weights of Fait-Shamir for Merkle commitment, after log d steps, to create a constant $f_{log(d)}(x)=g_{log(d)}(x)+a_{log(d)}Â·h_{log(d)}(x)$ verified by $f(z_1)=f(w), d/2^{log(d)} < 1.$
