# ETAAcademy-ZKMeme: 66. Indistinguishability Obfuscation

<table>
  <tr>
    <th>title</th>
    <th>tags</th>
  </tr>
  <tr>
    <td>66. Indistinguishability Obfuscation</td>
    <td>
      <table>
        <tr>
          <th>zk-meme</th>
          <th>basic</th>
          <th>quick_read</th>
          <td>iO</td>
        </tr>
      </table>
    </td>
  </tr>
</table>

[Github](https://github.com/ETAAcademy)｜[Twitter](https://twitter.com/ETAAcademy)｜[ETA-ZK-Meme](https://github.com/ETAAcademy/ETAAcademy-ZK-Meme)

Authors: [Evta](https://twitter.com/pwhattie), looking forward to your joining

# Indistinguishable Obfuscation: The Cryptographic Holy Grail from Classical Constructions to Quantum Applications

Indistinguishable Obfuscation (iO) stands as the "Holy Grail" of cryptography, representing the pinnacle of program obfuscation techniques. It transforms functionally equivalent but structurally different programs into computationally indistinguishable forms, requiring only the assumption of iO + NP hardness to construct virtually all advanced cryptographic primitives including one-way functions, public key encryption, functional encryption, fully homomorphic encryption, and zero-knowledge proofs.

The evolution of classical iO has progressed from early constructions relying on complex tools like multilinear maps and functional encryption to modern implementations based on LWE and pseudorandom generators. However, it faces critical challenges with LWE-with-hint constructions being vulnerable to zeroizing attacks where adversaries can exploit decryption hints to recover secret information. To address these vulnerabilities, researchers have proposed innovative techniques such as equivocal matrix distributions and CRO (Circular Security with Random Opening) assumptions, creating "ambiguous" systems with exponentially many solutions and non-deterministic marginally random hints to resist attacks.

In the quantum realm, quantum indistinguishable obfuscation extends classical circuits to quantum state outputs, forming five variant hierarchies. These range from the strongest full-classical (C,C,C)-iO capable of constructing OWF and all classical cryptographic primitives, to the weakest full-quantum (Q,Q,Q)-iO limited to basic quantum primitives like OWSG and EFI pairs. While quantum measurement randomness prevents direct construction of one-way functions, quantum iO can still generate useful quantum cryptographic tools that may exist without requiring OWF.

As a significant application of iO in quantum cryptography, Single-Decryptor Encryption (SDE) leverages unclonable quantum states as decryption keys. Based on coset states and iO constructions, SDE achieves anti-collusion decryption capabilities and has evolved from initially requiring sub-exponential security assumptions to depending only on polynomial-secure iO and OWF. With security guaranteed through computational monogamy, quantum Goldreich-Levin lemma, and simulation techniques, SDE provides new solutions for access control and copyright protection scenarios, demonstrating the tremendous potential of iO's transformation from theoretical "Holy Grail" to practical applications.

---

## 1. Indistinguishability Obfuscation (iO) and NP Assumptions

**Indistinguishability Obfuscation (iO)** is one of the most powerful and foundational concepts in modern cryptography. Often referred to as the "Holy Grail" of cryptography, iO enables the transformation of a program into an obfuscated version that preserves its functionality but hides its internal implementation. The security requirement is that the obfuscated versions of any two functionally equivalent programs must be computationally indistinguishable.

### What Is iO?

Program obfuscation aims to make a program “look like gibberish” to anyone trying to analyze it—yet still work exactly as intended. In the case of **Indistinguishability Obfuscation**, the goal is not to hide _everything_, but to ensure that **any two programs that compute the same function** become indistinguishable after obfuscation.

An iO system consists of two algorithms:

- **Obf**$(1^\lambda, \Pi)$: Takes a security parameter and a Boolean circuit $\Pi$, and outputs an obfuscated version $\widetilde{\Pi}$.
- **Eval**$(1^\lambda, \widetilde{\Pi}, x)$: Executes the obfuscated circuit $\widetilde{\Pi}$ on input $x$, returning the result.

Correctness requires that:

$$
\Pr[\text{Eval}(1^\lambda, \text{Obf}(1^\lambda, \Pi), x) = \Pi(x)] = 1
$$

for all $x$ and all circuits $\Pi$.

One of the core security properties of **Indistinguishability Obfuscation (iO)** is that it hides the _implementation details_ of a program while preserving its _functionality_. More precisely, for any two circuits $\Pi_0$ and $\Pi_1$ that are **functionally equivalent**—i.e., they produce the same output on every possible input $x$, so that $\Pi_0(x) = \Pi_1(x)$ for all $x$—their obfuscated versions must be **computationally indistinguishable**. Formally, this means:

$$
\text{Obf}(1^\lambda, \Pi_0) \approx \text{Obf}(1^\lambda, \Pi_1),
$$

where the indistinguishability holds against all polynomial-time adversaries, with distinguishing advantage bounded by a negligible function $\epsilon(\lambda)$.

In simple terms, even though the original circuit $\Pi$ might represent a cryptographic function or a logical check, and its obfuscated version $\widetilde{\Pi}$ may appear completely unintelligible or random, it must still preserve the same input-output behavior. Crucially, **no efficient adversary should be able to tell** whether the obfuscated code corresponds to $\Pi_0$ or $\Pi_1$, even if they have full access to the obfuscated program.

This is what sets iO apart from earlier and stronger notions such as **Virtual Black-Box (VBB) obfuscation**. VBB obfuscation requires that the obfuscated program reveal no more than black-box access to the original function—essentially making it impossible to learn anything about the program beyond its behavior. However, seminal results by Barak et al. showed that general-purpose VBB obfuscation is impossible to achieve.

To overcome this impossibility, **Barak et al. introduced iO as a weaker but still powerful alternative**, requiring only that obfuscations of functionally equivalent programs be indistinguishable. This more relaxed notion turns out to be **both feasible and extremely powerful**—it is sufficient to realize a wide array of cryptographic primitives. Starting from 2013, Garg et al. proposed the first candidate constructions for iO, sparking a major wave of research.

### What Can iO Do?

Once iO is assumed to exist—even combined with _very weak assumptions_ such as NP-hardness—it can be used to construct nearly all major cryptographic primitives, including:

- **OWFs (One-Way Functions)**
- **PRFs (Pseudorandom Functions)**
- **Broadcast Encryption**
- **Attribute-Based Encryption (ABE)**
- **Functional Encryption (FE)**
- **Fully Homomorphic Encryption (FHE)**
- **Public-Key Encryption (PKE)**
- **Verifiable Delay Functions (VDFs)**
- **Zero-Knowledge Proofs (ZK)** for all NP languages

In fact, just assuming iO and the existence of hard problems in NP (i.e., NP $\nsubseteq$ i.o.BPP) is enough to _derive_ OWFs. From there, all symmetric cryptography primitives become constructible.

### Realizing iO in Practice

Historically, constructing iO required intricate mathematical tools such as:

| Approach                                 | Status        | Security | Practicality | Remarks                         |
| ---------------------------------------- | ------------- | -------- | ------------ | ------------------------------- |
| Multilinear Maps                         | Broken        | Weak     | Poor         | Important historically          |
| Garbled Circuits + Functional Encryption | Theoretical   | Medium   | Poor         | Highly complex constructions    |
| LWE + FE + Bootstrapping                 | Mainstream    | Strong   | Improving    | Dominant post-2020 method       |
| Low-degree Encodings + PRGs              | Emerging tool | Strong   | Modular use  | Widely used as a building block |

Early iO constructions relied on sophisticated mathematical frameworks such as:

- **Multilinear maps**
- **Lattice-based cryptography**
- **Garbled circuits**
- **Functional Encryption (FE)**

Among these, **Functional Encryption (FE)** plays a pivotal role in many constructions. FE is an advanced form of encryption in which the secret key is associated with a function $f$, allowing the decryptor to learn only the value $f(x)$ from an encryption of $x$, without revealing $x$ itself.

In the context of iO, FE is often used as a building block in **bootstrapping frameworks**—recursive constructions that embed a program's behavior into a functional key. To obfuscate a circuit, one might encrypt each gate or bit of the program using FE, then apply decryption logic to simulate program execution. This recursive layering allows the construction to approximate the behavior of an obfuscated program.

However, these bootstrapped constructions are often extremely **complex and computationally expensive**. For each bit of the program, one needs to run an FE encryption and potentially a decryption within another FE circuit, leading to highly nested and inefficient structures.

To address these inefficiencies, more recent iO research has focused on constructions built from:

- **Learning With Errors (LWE)**: a well-established lattice-based hardness assumption
- **Pseudorandom Generators (PRGs)** derived from iO
- **Low-degree encodings**, which allow for compact and algebraic representations of circuits

These newer approaches aim to reduce the reliance on heavy FE machinery and improve the practicality of iO implementations.

### iO Implies OWF: Classical Case

In the **classical world**, it is known that iO implies OWF. Here’s a simple construction:

Let $Z$ be a circuit that outputs 0 on all inputs. Define:

$$
f(r) := \text{Obf}(Z; r)
$$

This function is easy to compute, but if iO is secure and NP is not in i.o.BPP, then $f$ becomes hard to invert—thus giving us a one-way function.

This derivation hinges on the **derandomizability** of the classical iO construction: the randomness $r$ used in obfuscation is embedded into the output deterministically.

### What About Quantum iO?

In the **quantum setting**, things become more subtle. Quantum computation is inherently probabilistic, due to superposition and measurement, so **obfuscation may not be deterministic**. This makes it difficult to apply the same classical technique for deriving OWFs from iO.

As a result, **quantum iO** (qiO) might not be sufficient to construct OWFs.

But researchers have shown that qiO can still be leveraged to construct _weaker_ but still meaningful quantum cryptographic primitives. These include:

- **OWSG**: One-Way State Generator
- **PRSG**: Pseudorandom State Generator
- **PRU**: Pseudorandom Unitary

These primitives are useful in settings like unclonable encryption, quantum software copy protection, and quantum money.

### Summary Diagram

```text
                 Classical World                           Quantum World
          ┌────────────────────────────┐         ┌──────────────────────────────┐
          │   iO + OWF ⇒ rich ecosystem │         │   quantum iO + NP ⊄ i.o.BQP  │
          └────────────┬───────────────┘         └─────────────┬────────────────┘
                       │                                        │
            iO ⇒ OWF possible                        iO ⇏ OWF (no derandomization)
                       ↓                                        ↓
              Derive symmetric crypto           Derive weaker primitives: OWSG, PRSG, etc.
```

---

## 2. LWE-with-Hint: Challenges and Advances Toward Secure iO

**Indistinguishability Obfuscation (iO)** remains one of the most powerful and elusive goals in modern cryptography. Over the years, its constructions have gradually shifted from relying on exotic and fragile primitives (e.g., multilinear maps, branching programs) to more conservative assumptions such as **Learning with Errors (LWE)**, **Learning Parity with Noise (LPN)**, and **Fully Homomorphic Encryption (FHE)**. A significant milestone in this transition was the work of Jain, Lin, and Sahai, who proposed iO constructions from seemingly "reasonable" computational assumptions.

However, many of these recent constructions rely on a class of assumptions referred to as **LWE-with-hint**. These constructions have proven to be **insecure** under various attacks. In particular, they suffer from structural weaknesses that make them vulnerable to **quantum adversaries**, rendering them **not post-quantum secure**.

### Hints, Homomorphic Encryption, and the Danger of Zeroizing Attacks

Many iO constructions based on LWE employ **homomorphic encryption** to encode circuits, with the aim of evaluating and decrypting parts of the program in an obfuscated yet functional way. To enable correct decryption or evaluation, these constructions often require exposing auxiliary information—referred to as **hints**—such as partial decryption randomness or helper circuits. These hints, however, may leak structural information that allows an adversary to **"zero out" the LWE noise**, a type of attack known as a **zeroizing attack**.

In practice, these hints are often constructed by revealing portions of ciphertext randomness or evaluating specific parts of the circuit under known inputs. Multiple research works have shown that such approaches result in **vulnerable constructions**, where the adversary can successfully recover internal secrets or even break the obfuscation entirely.

### xiO and the Quest for Efficient Obfuscation

To mitigate the efficiency bottlenecks in iO, researchers introduced a restricted variant known as **Exponentially Efficient iO (xiO)**. The goal of xiO is to obfuscate functions with **small circuits but large truth tables**, such as cryptographic hash functions or lookup tables. In xiO, the obfuscation procedure is allowed to run in **exponential time** with respect to the input length (i.e., the size of the truth table), but the **resulting obfuscated program must remain short**, ideally **sublinear** in the size of the truth table.

Typical xiO constructions follow this high-level approach:

- Encode the function $\Pi$ as a truth table.
- Use **GSW-style LWE-based homomorphic encryption** to compute an encrypted form of the truth table: $\text{HEnc}(\Pi)$.
- Perform homomorphic evaluation on the encrypted circuit to obtain $\text{Enc}(\text{TT})$.
- **Open** (partially decrypt) the encrypted truth table to reveal outputs while minimizing information leakage.

This final step—opening the encrypted truth table—is where hints become essential, and simultaneously where the **greatest vulnerabilities arise**.

### The BDGM Framework and the Role of Hints

The **BDGM framework** offers a general blueprint for building efficient iO. It starts by constructing xiO for simple functions and then **bootstraps** it into full iO using known transformations. Consider a Boolean circuit $\Gamma : [h] \times [k] \to {0, 1}$ represented as an $h \times k$ truth table (i.e., a Boolean matrix of size $N = hk$). This compact form allows for structured handling during encryption and obfuscation.

BDGM relies on the observation that **FHE decryption** consists of two steps: a **linear operation** on the secret key followed by a **rounding step**. This decomposition allows us to:

- Encrypt the circuit $\Gamma$ using **FHE**.
- Encrypt the FHE secret key using **linearly homomorphic encryption (LHE)**.
- Homomorphically evaluate the encrypted $\Gamma$ using FHE.
- Extract the **linear part of the FHE decryption** and evaluate it homomorphically under LHE.
- Provide a **short hint** to help recover the rounded result.

The final obfuscated program is given by the tuple $(\text{ctxt}{\text{FHE}}, \text{ctxt}{\text{LHE}}, \text{hint})$.

However, **the hint remains the weakest link** in this construction. If the hint uniquely determines an internal variable, such as the secret key or evaluation randomness, an attacker can exploit it to compromise the system. This is particularly dangerous when the decryption hint reveals a deterministic mapping between known ciphertext components and the secret.

### Overcoming Uniqueness: Sampling from Rich Solution Spaces

To defend against this vulnerability, recent constructions aim to **eliminate the uniqueness of the hint**. Instead of producing a single deterministic decryption hint, the idea is to **design a setting in which many possible valid hints exist**, and one is **sampled randomly** during obfuscation. This approach ensures that even if the adversary obtains the hint, they cannot deduce the underlying secrets.

This involves constructing LHE ciphertexts of the form:

```math
\text{ctxt}_{\text{LHE}} = (B, C), \quad C = R B + E + \text{Encode}(sk_{\text{FHE}}) \mod q,
```

where:

- $R$ is a random noise matrix,
- $E$ is a small noise term,
- $\text{Encode}(\cdot)$ maps secrets to error-correcting representations.

After FHE evaluation, we get:

$$
\text{ctxt}'_{\text{LHE}} = (B, L C) = (B, L R B + L E + \text{Encode}(\Gamma)) \mod q.
$$

The challenge is to generate a hint matrix $\tilde{R}$ such that:

$$
L C \approx \tilde{R} B + \text{Encode}(\Gamma) \mod q.
$$

If the matrix $B$ is chosen from a **uniform distribution**, then this equation has **only one valid solution** for $\tilde{R}$—namely $\tilde{R} = L R$. This enables a **zeroizing attack**: the attacker can recover $R$ and subsequently decrypt the entire system.

To avoid this, the solution is to sample $B$ from a specially crafted **equivocal distribution** that ensures the lattice $\Lambda_q(B)$ contains a **dense sublattice**, so the equation has **exponentially many valid solutions** for $\tilde{R}$. This randomness introduces **ambiguity** into the decryption hint, protecting against structural leakage.

Three novel tools are introduced to enable this secure hint generation:

- **Equivocal Matrix Distributions**: Special distributions over matrices that admit many short solutions to the LWE equation, allowing for _equivocation_—the generation of many indistinguishable valid hints.

- **Primal Lattice Trapdoors**: A new form of trapdoor function that allows for efficient sampling from these equivocal distributions while preserving security. Unlike traditional "G-trapdoors," they support usage in the equivocal setting.

- **Equivocal LWE Assumption**: A strengthened version of the LWE assumption asserting that LWE remains hard even when the matrix is drawn from an equivocal distribution and the secret is obfuscated. This provides a **stronger post-quantum foundation** for iO constructions.

---

### Circular Security with Random Opening (CRO): A New Assumption for Obfuscation

In recent efforts to construct secure **indistinguishability obfuscation (iO)**, researchers have proposed a new assumption known as **Circular Security with Random Opening (CRO)**. This assumption aims to overcome vulnerabilities found in earlier LWE-based constructions—particularly those relying on deterministic or structured hint mechanisms that are susceptible to **zeroizing attacks**.

The CRO assumption envisions a setting where the adversary obtains multiple “**openings**” of ciphertexts encrypting **zero**—referred to as _zero encryptions_. These ciphertexts are generated using the **GSW** homomorphic encryption scheme, and their openings are derived via carefully designed procedures from existing LWE samples. Crucially, these **hints are marginally random**—they contain enough entropy to resist information leakage, yet do not reveal critical structural information such as the LWE noise or secret. This differs from earlier assumptions (e.g., Equivocal LWE), which exhibit structural leakage due to deterministic or highly constrained hint generation.

Despite appearing stronger than classical _hint-LWE_ assumptions, variants such as _evasive LWE_ have been shown vulnerable to the powerful **Hopkins-Jain-Lin (HJL)** technique, which yields **new zeroizing attacks** even against seemingly hardened models.

### The Zeroizing Attack Paradigm

Zeroizing attacks represent a powerful family of techniques in the cryptanalysis of obfuscation. These attacks exploit structural information leaked through the obfuscation process—particularly from ciphertexts encrypting zero—and combine this with hints to reconstruct secrets or trapdoors. A representative zeroizing structure takes the following form:

```math
\begin{bmatrix}
C \\
\tilde{R}_b B
\end{bmatrix}
=
\begin{bmatrix}
I \\
L_b
\end{bmatrix}
R B +
\begin{bmatrix}
E \\
\tilde{E}_b
\end{bmatrix}
+
\begin{bmatrix}
\text{Encode(sk)} \\
0
\end{bmatrix}
\mod q
```

By applying a linear transformation—specifically, multiplying on the left by a vector $z^T = (t^T, -x^T)$—the adversary can eliminate known structural components:

```math
z^T
\begin{bmatrix}
C \\
\tilde{R}_b B
\end{bmatrix}
= t^T \cdot \text{Encode(sk)} + t^T E - x^T \tilde{E}_b \mod q
```

This computation may yield valuable information about the underlying secret key $\text{sk}$, the noise distribution, or the sublattice structure of $B$. Thus, previous iO constructions based on _deterministic hints_ suffer from a fundamental vulnerability: the hint can collapse the entropy of the LWE instance, enabling recovery of secret components.

### The CRO Assumption: Randomized and Non-Revealing Hints

The **CRO assumption** provides a promising direction to avoid these attacks. It is based on a new mechanism for LWE sample generation called **Oblivious LWE Sampling**, which ensures that the sampled secret and noise terms are **independent and uniformly random**, and that the **hint is uncorrelated with the sample content**.

Under CRO, even though the adversary may receive ciphertexts along with their openings (denoted $C^*$ and associated hints), they cannot distinguish between two scenarios:

- **Real world**: LWE sample + opening of ciphertext encrypting 0
- **Ideal world**: Uniform random ciphertext + simulated hint

The key innovations in CRO-based constructions include the following:

- **Pseudorandom Hints**: In the real distribution, the hints are **marginally random**, while in the ideal distribution, they are **pseudorandom**. Thus, no efficient adversary can use the hints to distinguish between real and simulated ciphertexts.

- **No Natural Noise Leakage**: Since only zero is encrypted, and the opening mechanism is randomized and non-deterministic, the LWE noise remains hidden. This thwarts all known **zeroizing attacks**, which rely on exploiting deterministic structure or observable noise patterns.

- **LWE Samples Remain Pseudorandom Given the Hint**: Even when the adversary sees both the LWE ciphertext and the corresponding opening, the ciphertext still looks pseudorandom. This property is crucial for resisting **quantum and classical attacks** alike.

### Oblivious LWE Sampling and the Construction of xiO

The **xiO** construction—targeting functions with large truth tables and small circuits—heavily relies on the new **Oblivious LWE Sampler**, a core primitive that samples LWE ciphertexts of the form $\tilde{s} A + \tilde{e}$, where $\tilde{s}$ and $\tilde{e}$ are both uniformly random and reusable.

The sampling mechanism is carefully crafted:

- The secret $\tilde{s}$ is encrypted using **GSW ciphertexts**.
- The noise $\tilde{e}$ is stored separately using **small-modulus LWE** samples with $\Delta \ll q$, ensuring compactness.
- This avoids the need to store $s$, $e$, or PRF seeds in the common reference string (CRS), and does not require trapdoors.

During homomorphic evaluation, GSW ciphertexts are transformed to encode $\tilde{s} A + \tilde{e} \mod q$, yielding a new ciphertext $\text{hct}'$. To make this ciphertext usable in both real and simulated settings, the hint $R^*$ associated with it is constructed such that:

- In the **real distribution**, $R^*$ is **marginally random**.
- In the **ideal distribution**, $R^*$ is **pseudorandom**, simulatable using only public randomness.

The scheme supports **re-randomization** of $\text{hct}'$ using public randomness $R$, via an update of the form $\text{hct}' \leftarrow \text{hct}' + \overline{B} R$. This process supports **simulation-based security** by allowing a simulator to "program" the desired output truth table $\text{TT}''$ into the CRS through the values of $R^*$.

---

## 3. Quantum Indistinguishability Obfuscation (Quantum iO)

In the **quantum setting**, indistinguishability obfuscation (iO) refers to the task of obfuscating **classical circuits**, while producing **quantum states** as the output. A **quantum iO scheme** consists of two quantum polynomial-time algorithms:

- **Obfuscator** $\text{Obf}(1^\lambda, C) \rightarrow \widetilde{C}$: Takes as input a security parameter $\lambda$ and a classical circuit $C$, and outputs a **quantum state** $\widetilde{C}$ representing the obfuscated version of $C$.
- **Evaluator** $\text{Eval}(\widetilde{C}, x) \rightarrow y$: On input the obfuscated state $\widetilde{C}$ and a classical input $x$, outputs a result $y \in \{0, 1\}$.

For any two functionally equivalent classical circuits $C_0$ and $C_1$ of the same size, their obfuscations $\widetilde{C}_0 = \text{Obf}(1^\lambda, C_0)$ and $\widetilde{C}_1 = \text{Obf}(1^\lambda, C_1)$ must be **computationally indistinguishable to any quantum polynomial-time (QPT) adversary**. That is:

$$
\left| \Pr[\mathcal{A}(\widetilde{C}_0) = 1] - \Pr[\mathcal{A}(\widetilde{C}_1) = 1] \right| \leq \text{negl}(\lambda)
$$

Additionally, the obfuscation must be **functionally correct** with overwhelming probability: for all $x$, the probability that $\text{Eval}(\widetilde{C}, x) \approx C(x)$ is at least $1 - \frac{1}{p(\lambda)}$, for any polynomial $p$.

### Differing-Inputs Obfuscation (diO)

While standard iO requires **complete functional equivalence** between obfuscated programs, a **stronger notion** called **Differing-Inputs Obfuscation (diO)** relaxes this requirement. diO assumes security even when two circuits differ on only a **single input**. More formally, if circuits $C_0$ and $C_1$ differ on at most one input $x$, and an adversary can distinguish between their obfuscations with noticeable advantage (≥ $\frac{1}{2} + \frac{1}{p(\lambda)}$), then an efficient **extractor** must exist that can identify such a differing input $x$ with non-negligible probability.

diO is particularly useful in **reductions from cryptographic primitives**, such as one-way functions (OWFs), where a reduction may create two circuits differing only on one unique input (e.g., using **unique witness properties of UP problems**), and rely on diO’s extractability to ensure security.

### Five Variants of Quantum iO

Quantum iO variants can be classified by a **three-part tuple (X, Y, Z)**, where:

- **X** specifies whether the **Obfuscator** is **Quantum (Q)** or **Classical (C)**.
- **Y** specifies whether the **Evaluator** is **Quantum (Q)** or **Classical (C)**.
- **Z** specifies whether the **obfuscated object** $\widetilde{C}$ is a **Quantum state (Q)** or **Classical string (C)**.

While 8 combinations are possible, only **five of them are meaningful** in cryptographic contexts—those that respect the fact that quantum states must be both generated and evaluated using quantum algorithms.

### Capability Hierarchy of Quantum iO Variants

The five meaningful variants of quantum iO yield a **hierarchy of cryptographic power**, summarized below (from strongest to weakest):

```text
  Strong ←─────────────→ Weak

  (C,C,C)-iO   Classical iO with quantum adversaries
       ↓        ⇒ OWF + PKE + Classical crypto primitives
  (C,Q,C)-iO   Quantum Eval, classical Obf/output
       ↓        ⇒ OWF + Quantum-Classical PKE + PRUs + Microcrypt primitives
  (Q,C,C)-iO   Quantum Obf, classical Eval/output
       ↓        ⇒ Quantum-Classical PKE + One-way puzzles, EFI pairs
  (Q,Q,C)-iO   Quantum Obf/Eval, classical output
       ↓        ⇒ QCCC-SKE + basic symmetric-key quantum primitives
  (Q,Q,Q)-iO   Fully quantum: state-in/state-out
                ⇒ QSKE + weakest but uniquely quantum primitives
```

Some key observations from this hierarchy:

- The **existence of OWF** is a fundamental dividing line. Only the (C,C,C) and (C,Q,C) variants can imply OWF.
- **PRUs (Pseudorandom Unitaries)** are quantum analogues of pseudorandom permutations and play a central role. From OWF, one can construct PRUs, which in turn yield many **quantum-specific primitives**.
- **OWSGs (One-Way State Generators)**, while weaker than OWFs, are foundational and can be constructed in nearly all variants.
- Although (Q,Q,Q)-iO is the weakest in terms of implication strength, it supports **quantum-native primitives** such as state generation, transformation, and encryption of quantum data.

### Quantum iO Without OWF: Weaker but Useful Primitives

Despite its limitations in constructing OWFs, **quantum iO** has been shown to enable a wide array of **quantum cryptographic primitives** that do not inherently require OWFs. These include:

- **EV-OWPuzz** (_Efficiently Verifiable One-Way Puzzles_): Hard to solve but easy to verify.
- **OWSGs** (_One-Way State Generators_): Generate quantum states that are hard to invert.
- **PRSGs** (_Pseudorandom State Generators_): Generate states indistinguishable from truly random quantum states.
- **PRUs** (_Pseudorandom Unitaries_): Quantum analogues of PRFs; essential for derandomization and secure computation.
- **OWPuzzs**: One-way puzzles offering security via verification difficulty separation.
- **EFI Pairs** (_Efficiently Far but Indistinguishable_): Pairs of functions or states that are computationally far apart but indistinguishable.
- **QCCC Encryption**: Quantum variants of symmetric or public-key encryption systems with classical-quantum interfaces.

---

### Constructing Cryptographic Primitives under Quantum iO and the Assumption $\text{NP} \nsubseteq \text{i.o.BQP}$

Quantum indistinguishability obfuscation (quantum iO) is a powerful cryptographic primitive with the potential to enable a broad range of quantum-secure applications. Under the assumption $\text{NP} \nsubseteq \text{i.o.BQP}$—that is, **no quantum polynomial-time algorithm solves all NP problems on infinitely many input lengths**—we can construct fundamental cryptographic primitives such as one-way functions (OWFs), quantum encryption schemes, pseudorandom unitary transformations, and others.

This complexity-theoretic assumption is **significantly weaker** than $\text{NP} \nsubseteq \text{BQP}$, as it only excludes quantum algorithms from solving NP-complete problems **on infinitely many input lengths**, rather than all. The **Valiant-Vazirani Theorem** further plays a key role in these constructions, as it allows any NP problem to be reduced (via randomized polynomial-time procedures) to a UP (unique witness) problem. This connection is critical for the security reductions used in the quantum setting.

### OWF Construction from Quantum iO

Under the classical setting of **(C,C,C)-iO**—where the obfuscator, evaluator, and obfuscated program are all classical—we can construct a **one-way function** based on the indistinguishability of two functionally different, yet structurally simple, circuits:

- **point function**:

```math
P_k(x) = \begin{cases} 1 & \text{if } x = k \\ 0 & \text{otherwise} \end{cases}
```

- **zero function**: $Z_m(x) = 0$ for all $x \in \{0,1\}^m$ — a

Though $P_k$ and $Z_m$ are clearly distinguishable by their functionality, the **quantum iO obfuscations** of these circuits are computationally indistinguishable:

$$
\text{Obf}(1^\lambda, P_k) \approx_c \text{Obf}(1^\lambda, Z_m)
$$

This indistinguishability stems from the hardness of solving UP instances under the $\text{NP} \nsubseteq \text{i.o.BQP}$ assumption. If an adversary could distinguish between $\text{Obf}(P_k)$ and $\text{Obf}(Z_m)$, it would imply the ability to solve UP problems (and therefore NP problems) in quantum polynomial time on infinitely many inputs—contradicting our foundational assumption.

According to Goldreich’s classical result (1990), **if there exists a pair of distributions that are statistically far apart yet computationally indistinguishable**, one can construct a **one-way function**. The pair $(\text{Obf}(P_k), \text{Obf}(Z_m))$ satisfies this criterion, yielding a construction of OWF. These are also referred to as **EFID (Efficiently Far but Indistinguishable) pairs**, and the **existence of EFID pairs is equivalent to the existence of OWFs**.

### Building Cryptographic Schemes in Different Quantum iO Models

Once OWFs are available (via the above construction), they can be used to instantiate further primitives such as pseudorandom functions (PRFs), public-key encryption (PKE), and symmetric-key encryption (SKE)—in both classical and quantum settings. Below we outline constructions in each of the five meaningful quantum iO variants.

#### **(C,C,C)-iO**: Fully Classical iO (Quantum Adversaries Allowed)

- **Obfuscator, Evaluator, and Circuit** are all classical.
- Based on the indistinguishability $\text{Obf}(P_k) \approx \text{Obf}(Z_m)$, one can construct OWFs.
- These OWFs form the foundation for **classical PKE, PRFs**, and other standard primitives—while maintaining quantum adversary resistance under the iO assumption.

#### **(C,Q,C)-iO**: Classical Obfuscator and Circuit, Quantum Evaluator

- Builds on the same OWF construction.
- Public-key encryption (PKE) is constructed classically, but the **evaluation is performed on a quantum computer**, enabling hybrid schemes like **QCCC PKE** (quantum-classical-classical PKE).
- The evaluation circuit is embedded in the obfuscated program, and decryption can leverage quantum capabilities.

#### **(Q,C,C)-iO**: Quantum Obfuscator, Classical Evaluation and Output

- In this case, OWF may not be constructible directly due to limitations of the iO model.

- Nevertheless, one can build **QCCC PKE schemes** using the indistinguishability of obfuscated circuits:

  - **Key Generation**: $pk = \text{Obf}(P_k)$, $sk = k$
  - **Encryption**: Construct a circuit $C$ that on input $k'$ returns $msg$ if $pk(k') = 1$, and $\perp$ otherwise. The ciphertext is $\text{ct} = \text{Obf}(C)$.
  - **Decryption**: $msg = \text{Eval}(ct, k)$

- These constructions enable **EV-OWPuzz (Efficiently Verifiable One-Way Puzzles)**, **OWSGs (One-Way State Generators)**, **EFI pairs**, and **QEFID pairs**—quantum versions of hard-to-invert but efficiently verifiable primitives.

#### **(Q,Q,C)-iO**: Quantum Obfuscator and Evaluator, Classical Output

- Enables **QCCC Symmetric-Key Encryption (SKE)** based on **multi-instance indistinguishability** between $\text{Obf}(P_k)$ and $\text{Obf}(Z_m)$.

- Scheme outline:

  - **Shared Key**: $k \in \{0,1\}^m$
  - **Encrypting 0**: $ct = \text{Obf}(Z_m)$
  - **Encrypting 1**: $ct = \text{Obf}(P_k)$
  - **Decryption**: Evaluate $ct$ on key $k$

- This construction yields a minimal yet quantum-secure SKE scheme based on indistinguishable obfuscated programs.

#### **(Q,Q,Q)-iO**: Fully Quantum iO

- The obfuscator, evaluator, and obfuscated circuit are all quantum.
- The same construction as above applies, but now the **ciphertexts are quantum states**.
- Enables **QSKE** (Quantum Symmetric-Key Encryption) schemes and is foundational for **state-based cryptographic primitives**.
- Although incapable of building OWFs directly, this model supports the construction of:

  - **OWSGs (One-Way State Generators)**
  - **PRSGs (Pseudorandom State Generators)**
  - **PRUs (Pseudorandom Unitaries)**
  - **EFI and QEFID Pairs**
  - **Quantum puzzles and encryption mechanisms**

The overall construction strategy can be visualized as follows:

```text
Quantum iO (of appropriate type) + NP ⊈ i.o.BQP
        ↓
Indistinguishable program pairs: Obf(P_k) ≈ Obf(Z_m)
        ↓
EFID pair existence
        ↓
One-Way Function (OWF)
        ↓
Quantum/classical encryption (QCCC PKE, SKE, QSKE), PRUs, EFI pairs, etc.
```

This framework demonstrates how even **modestly strong assumptions** in complexity theory (like $\text{NP} \nsubseteq \text{i.o.BQP}$) can give rise to a **rich set of quantum-secure cryptographic primitives** when combined with carefully constructed variants of indistinguishability obfuscation.

---

## 4. Single-Decryptor Encryption (SDE)

**Single-Decryptor Encryption (SDE)** is a **quantum-enhanced public-key encryption (PKE)** scheme in which the decryption key is not a classical bit string but rather an **unclonable quantum state**. While encryption remains entirely classical, the secret key leverages the **quantum no-cloning theorem**, ensuring that decryption capability cannot be copied or redistributed. This paradigm introduces a fundamentally new security property—**single-use decryption**—that is unattainable in purely classical settings.

The concept of SDE was introduced by **Coladangelo, Liu, Liu, and Zhandry (CRYPTO 2021)**. Their construction is based on:

- **iO (indistinguishability obfuscation)** secure against **sub-exponential adversaries**,
- **One-Way Functions (OWFs)**, and
- **Learning With Errors (LWE)** under **polynomial-time hardness** assumptions.

Several variants of SDE have since been proposed, including:

- **Secret-Key SDE**: where the sender and receiver share a classical or quantum secret key. The decryption key remains a quantum state, and the security is **one-time**, meaning the key is valid for a single ciphertext. This version forms the foundation for theoretical exploration of quantum decryption.

- **Collusion-Resistant SDE**: strengthens the model by requiring that even if an adversary holds **t quantum decryption keys**, they cannot construct a **(t+1)th** key capable of decrypting a new ciphertext. This feature is critical in **access control**, **digital rights management**, and **secure content distribution**.

### A New Construction: SDE from Polynomial-Security iO

Recent advances demonstrate that SDE can be constructed from **only polynomial-security iO and OWF**, relaxing the previous reliance on sub-exponential assumptions. The construction employs:

- **iO to encode access structures**, enabling control over decryption permissions.
- A **Quantum Key Encapsulation Mechanism (QKEM)** where **unclonable quantum states** serve as decryption keys.

### Coset States: The Quantum Decryption Keys

At the core of SDE is the **coset state**, an unclonable quantum state that forms the decryption key. Let $A \subseteq \mathbb{F}_2^n$ be a subspace and $A^\perp$ its **dual space**. For $s, t \in \mathbb{F}_2^n$, the coset state is defined as:

$$
|A_{s,t}\rangle := \sum_{a \in A} (-1)^{\langle a, t \rangle} |a + s\rangle
$$

This state possesses two critical properties:

- **Unclonability** due to quantum mechanics.
- A specific **Fourier dual structure**: applying the Hadamard transform $H^{\otimes n}$ yields the dual state $|A^\perp_{t,s}\rangle$.

These states underpin the encryption's secrecy and the system’s resistance to cloning or multi-decryption.

### SDE Scheme Overview

The SDE construction consists of the following components:

**Key Generation (KeyGen)**

- Choose a random subspace $A \subseteq \mathbb{F}_2^n$ and values $s, t \in \mathbb{F}_2^n$.
- Construct the **coset state** $|A_{s,t}\rangle$ to serve as the **quantum decryption key**.
- Create two obfuscated circuits via iO:

  - $C_{mc} := \text{iO}(A + s)$
  - $C^\perp_{mc} := \text{iO}(A^\perp + t)$

- Set:

  - **Public Key**: $pk = (C_{mc}, C^\perp_{mc})$
  - **Secret Key**: $sk = |A_{s,t}\rangle$

**Encryption (Enc)**

To encrypt a message $m \in \{0,1\}^{\ell_{\text{msg}}}$:

- Sample a random string $k \in \{0,1\}^{\ell_{\text{msg}}}$.
- Construct two circuits:

  - $P[C_{mc}, k \oplus m]$: Outputs $k \oplus m$ if input $x \in A + s$, else outputs all-zero.
  - $P[C^\perp_{mc}, k]$: Outputs $k$ if input $x \in A^\perp + t$, else outputs all-zero.

- Obfuscate both via iO to obtain:

  - $P_e = \text{iO}(P[C_{mc}, k \oplus m])$
  - $P_e^\perp = \text{iO}(P[C^\perp_{mc}, k])$

- Output the ciphertext:

  $ct = (P_e, P_e^{\perp})$

**Decryption (Dec)**

Given the quantum decryption key $|A_{s,t}\rangle$:

- Evaluate $P_e$ using $|A_{s,t}\rangle$ to obtain $k \oplus m$.
- Apply the Hadamard transform to get $|A^\perp_{t,s}\rangle$ and evaluate $P_e^\perp$ to obtain $k$.
- XOR the two values to recover the original message $m$.

### Security Analysis

The security of the scheme hinges on a **quantum version of the Goldreich-Levin (GL) Lemma**, **computational monogamy**, and **simulatability** arguments.

#### Step 1: **Simulated Encryption**

Even without knowledge of $s$ or $t$, one can generate **indistinguishable ciphertexts** using alternate circuits $Q[C_{mc}, A, f, k]$ that mimic the behavior of $P[C_{mc}, k \oplus f(s)]$. Since these circuits agree on $A + s$ and output zeros otherwise, **iO ensures** their obfuscations are computationally indistinguishable.

#### Step 2: **Attacker Simulation and Monogamy Reduction**

Suppose an adversary triple $(\mathcal{A}, \mathcal{B}, \mathcal{C})$ can extract hidden information about both $s$ and $t$ from the coset state and obfuscated programs. The adversary’s success in predicting $\langle r_B, s \rangle \oplus \langle r_C, t \rangle$ with advantage $\epsilon$ implies a violation of **computational monogamy of entanglement**.

To reduce to this contradiction:

- Replace the challenge bit with $\text{coin}' = \text{coin} \oplus \langle r, s \rangle$.
- Show that successful distinguishing now implies the ability to compute inner products with $s$ or $t$, contradicting the hardness of the coset state problem.

Formally, for all quantum polynomial-time adversaries $(\mathcal{A}, \mathcal{B}, \mathcal{C})$, we must have:

$$
\Pr[b_B \oplus b_C = \langle r_B, s \rangle \oplus \langle r_C, t \rangle] \le \frac{1}{2} + \text{negl}(\lambda)
$$

This guarantees the **unforgeability of quantum decryption keys**, even under collusion, and forms the basis for the scheme’s security.
