# ETAAcademy-ZKMeme: 69. DePIN & IoT

<table>
  <tr>
    <th>title</th>
    <th>tags</th>
  </tr>
  <tr>
    <td>69. DePIN & IoT</td>
    <td>
      <table>
        <tr>
          <th>zk-meme</th>
          <th>basic</th>
          <th>quick_read</th>
          <td>DePIN_IoT</td>
        </tr>
      </table>
    </td>
  </tr>
</table>

[Github](https://github.com/ETAAcademy)｜[Twitter](https://twitter.com/ETAAcademy)｜[ETA-ZK-Meme](https://github.com/ETAAcademy/ETAAcademy-ZK-Meme)

Authors: [Evta](https://twitter.com/pwhattie), looking forward to your joining

# Zero-Knowledge Proofs in Decentralized Physical Infrastructure Networks

DePIN, as a decentralized physical infrastructure network that integrates Web 3.0, IoT, ZK, AI, and blockchain technologies, achieves ecosystem collaboration through token incentive mechanisms across more than 300 projects and 21 million active devices, thereby supporting the autonomous management of both physical and digital resource networks.

To address security challenges such as IoT device vulnerabilities and limited processing capabilities, the system constructs decentralized security frameworks that integrate blockchain, zero-knowledge proofs, zero-trust architecture, and post-quantum cryptography, while implementing privacy protection and resistance against quantum attacks through techniques such as ring signatures, DPoS consensus, and DQN-based dynamic key selection.

For device trust establishment in DePIN, zero-knowledge proof–based registration and authentication frameworks enable non-revealing verification of device attributes, relying on different types of issuers that provide verifiable credential (VC) credentials via a three-stage process of Attestation, Setup, and Registration.

Meanwhile, to address authentication challenges of ICN in IoT environments, complete workflows — including Setup for key generation, KeyGen for private key and evidence creation, encryption for generating access policy trees, ZKP protocols for authenticity verification, and recursive decryption for secret reconstruction — ultimately form an intelligent DePIN-IoT ecosystem that both protects privacy and ensures security.

---

## 1. DePIN: Decentralized Physical Infrastructure Networks

**DePIN (Decentralized Physical Infrastructure Networks)** represents the convergence of Web 3.0 and the Internet of Things (IoT), designed to address key challenges of centralized infrastructures in the digital era—such as data privacy leaks, service disruptions, and high scalability costs.

The concept has evolved over time: from IoTeX’s proposal of _MachineFi_, to Lattice’s suggestion of _TIPIN_, and finally, the community-driven adoption of the term _DePIN_ in a Messari Twitter poll in November 2022. Compared to traditional infrastructure networks, DePIN is characterized by four core principles:

- **Collective Ownership & Incentives** – Tokenized rewards foster bottom-up self-organization, preventing monopolistic control.
- **Cost Efficiency** – Market-driven economics and participant-maintained devices lower operating costs, while transparent governance reduces corruption.
- **Resilience & Security** – Decentralization ensures fault tolerance, while blockchain guarantees data integrity and privacy.
- **Openness & Innovation** – Reduced entry barriers allow new participants to challenge legacy incumbents and foster innovation.

### A Growing Ecosystem

By 2025, DePIN has matured into an ecosystem of over **300 projects and 21 million active devices**, enabling individuals and organizations to collectively operate wireless networks, energy grids, and transportation services. Through the integration of blockchain, cryptoeconomics, AI, and IoT autonomy, DePIN overcomes the limitations of traditional centralized automation systems and creates self-governing, trustless economic entities.

The **three-layer architecture** of DePIN provides the foundation for autonomous services:

- **Physical/Operational Layer** – IoT devices (sensors, actuators, robots) handle data collection and real-world execution, secured by hardware integration to ensure data integrity and device authentication.
- **Intelligence & Verification Layer** – AI/ML models process sensor data, enable real-time decision-making, and conduct off-chain verification, improving responsiveness and optimizing resource allocation.
- **Blockchain & Governance Layer** – Decentralized ledgers record transactions, execute smart contracts, and provide immutable auditability and trustless coordination.

### Integration of AI, IoT, and Blockchain

Projects like **Helium** and **Filecoin** have demonstrated how token incentives can encourage participants to contribute physical resources to networks. By merging AI, blockchain, and IoT, DePIN enables:

- **Autonomous Decision-Making** – AI analyzes real-time IoT data to optimize responses.
- **Secure Transactions** – Blockchain ensures immutability and security in M2M (machine-to-machine) exchanges.
- **Programmable Economies** – Smart contracts allow IoT devices to engage directly in economic activity, managing **Real and Digital World Assets (RDWAs)**.

AI enhances asset management by interpreting sensor data, performing predictive maintenance, and coordinating logistics (repairs, replacements, inspections). DePIN networks support autonomous operations—from vending machines and EV charging to AI-driven autonomous vehicles.

Crucially, DePIN networks exhibit **adaptive organization**, dynamically restructuring in response to environmental or resource changes to maintain efficiency and resilience.

### Security and Trust in a Trustless World

DePIN relies on **three security pillars** to operate safely in adversarial, decentralized environments:

- **Oracles** – Bridging real-world data with on-chain smart contracts.
- **Zero-Knowledge Proofs (zkSTARKs)** – Validating off-chain computations and sensor readings without revealing sensitive data, while reducing on-chain costs.
- **Trusted Execution Environments (TEEs)** – Secure enclaves (e.g., Intel TDX) isolate critical computations and provide verifiable execution proofs.

Complementing these is **software verification** through DevSecOps, VeriDevOps, and **TrustOps** frameworks, which embed trust, validation, and security into the entire software lifecycle.

TrustOps introduces a **evidence-driven trust model**:

- Raw evidence (code changes, build logs) is cryptographically authenticated.
- Authenticated evidence becomes _verifiable evidence_ via consensus.
- Verifiable evidence triggers automated actions (e.g., access control, deployment permissions), generating new evidence in a continuous trust loop.

### Infrastructure Layers and Resource Networks

The DePIN infrastructure comprises:

- **Overlay Networks** – Peer-to-peer topologies ensure efficient communication without centralized servers, supporting blockchain-based value exchange.
- **Underlay Networks** – Core networks, wireless access points, and terminals manage physical data transmission.
- **Endpoints** – Devices like sensors, servers, and accelerators form the operational backbone.

DePIN applications fall into **two major categories**:

- **Physical Resource Networks** – Location-based IoT deployments such as energy monitoring, smart city infrastructure, environmental sensors, mobility tracking, healthcare monitoring, and decentralized wireless networks (5G, WiFi, LoRaWAN, Bluetooth).
- **Digital Resource Networks** – Shared digital assets providing cost-efficient and accessible services:

  - **Bandwidth Networks** (VPNs, CDNs, decentralized browsers)
  - **Storage Networks** (distributed file systems, databases)
  - **Compute Networks** (general-purpose and specialized compute marketplaces)
  - **AI Networks** (ML models, AI frameworks, GPU marketplaces)

Together, these form a comprehensive DePIN ecosystem spanning physical and digital resources.

### Operational Mechanics

DePIN’s operation is powered by **deployers** (who provide devices such as sensors, servers, or GPUs) and **miners** (who validate blockchain transactions for rewards). Smart contracts manage device allocation, data authorization, identities, reputation, and governance.

Users interact via **DApps**, purchasing services that trigger smart contract execution. Confirmed transactions allocate resources, and service providers are compensated through token rewards. This mechanism ensures self-sustaining and transparent infrastructure management.

### Overcoming Scalability & Interoperability Challenges

As DePIN expands into **autonomous machine networks**, scalability and interoperability become critical. Key solutions include:

- **Layer-2 technologies** (state channels, sidechains, rollups) to boost throughput and reduce latency.
- **Cross-chain protocols** (atomic swaps, relay chains) to enable seamless coordination across blockchains, vital for industries like energy management and robotics.

By enabling both internal M2M communications and external integrations with verifiable blockchain-backed security, DePIN provides the foundation for large-scale deployment and cross-industry collaboration—unlocking broad **socioeconomic impact**.

---

## 2. Internet of Things (IoT)

The **Internet of Things (IoT)**, first proposed at MIT in 1999, envisions the interconnection of trillions of physical objects (“things”) enabled by four technological pillars: RFID, sensors, smart technologies, and nanotechnology. IoT systems typically operate across **five stages**:

- **Data Collection** – capturing information from diverse sensors and RFID tags.
- **Storage** – retaining data in cloud-based data centers.
- **Intelligent Processing** – real-time analysis in the cloud to provide smart services.
- **Data Transmission** – ensuring continuous flow of information between stages.
- **Delivery** – securely and accurately distributing results to target devices.

While this architecture enables large-scale interconnectivity, it also introduces **unprecedented security challenges**, with vulnerabilities at every layer.

### Trust Management Challenges

IoT trust management faces severe difficulties:

- **Physical Vulnerability** – Devices often lack tamper-resistant casings, rely on low-cost CPUs without advanced protection, and expose interfaces (e.g., JTAG) that can be exploited.
- **Limited Processing Power** – Many devices can only handle lightweight tokens, leaving them susceptible to brute-force attacks.
- **Weak Memory Protection** – The absence of virtualization allows malicious code to access credentials of other processes, enabling insider attacks.

To address these risks, **dynamic trust management systems** are required, allowing compromised devices to be revoked while safeguarding credentials via **Hardware Security Modules (HSMs)**, **Trusted Platform Modules (TPMs)**, or software-based key vaults. At the network level, IoT systems must ensure:

- **Confidentiality & Integrity** (AES encryption, message authentication codes).
- **Authentication & Authorization** (e.g., a glucose monitor should only accept input from an insulin pump, not a blood pressure meter).
- **Availability** (resilience against DoS attacks).
- **Non-repudiation** (accountability for all actions).

### Toward a Secure IoT Framework

Traditional identity management and access control are insufficient for IoT, due to:

- **Centralization** – single points of failure and weak auditability.
- **Privacy Risks** – conventional authentication exposes sensitive user/device information.
- **Quantum Vulnerability** – future quantum computing could break existing cryptography.

Thus, IoT security requires a **Decentralized + Privacy-Preserving + Quantum-Resistant** framework, built on:

- **Blockchain** – immutable records for identity and access management, ensuring traceability and auditability.
- **Zero-Knowledge Proofs (ZKPs)** – authentication and verification without disclosing sensitive data.
- **Zero-Trust Architecture (ZTA)** – “never trust, always verify,” minimizing insider threats by re-authenticating every request.
- **Post-Quantum Cryptography (PQC)** – algorithms like NTRU and Kyber to ensure resilience against quantum attacks.
- **Hybrid Reinforcement-Lattice Key Generation** – a cryptographic scheme combining lattice-based cryptography with reinforcement learning for secure and efficient key management.
- **Deep Q-Network Multi-Factor Secure Keys (DQN-MFSK)** – dynamic selection of multi-factor keys (password, biometric, token) using deep reinforcement learning.

### Privacy and Consensus Mechanisms

To enhance privacy and scalability, IoT leverages advanced cryptographic and consensus techniques:

- **Ring Signatures** – enable group-based anonymous authentication. A message signed with $S = \sigma(m, {PK_1, \dots, PK_n})$ can be verified as coming from someone within the group, but without revealing which member signed it. This preserves **device anonymity** in IoT transactions.

- **Delegated Proof of Stake (DPoS)** – ensures blockchain efficiency and scalability by electing a small set of delegates through stakeholder voting. A delegate $i$ is chosen with probability $p_i = \frac{v_i}{\sum_j v_j}$, where $v_i$ is the number of votes received. This model reduces overhead and improves throughput, making it well-suited for **high-concurrency IoT environments**.

### Multi-Factor Authentication with Dynamic Key Selection

IoT systems increasingly rely on **multi-factor authentication (MFA)** combining:

- Password factor $K_{password}$
- Biometric factor $K_{biometric}$ (fingerprint, facial recognition)
- Token factor $K_{token}$ (hardware keys, OTPs)

The final authentication key is derived as:

$K_{auth} = H(K_{password} \, || \, K_{biometric} \, || \, K_{token})$

While robust, static concatenation is not always optimal—depending on context, one factor may be more secure than others (e.g., biometrics in one case, hardware tokens in another).

To adapt, IoT integrates **Deep Q-Networks (DQN)**, enabling systems to dynamically select the most suitable factor combination in real time.

The Q-value update follows the Bellman equation:

$Q(s_t, A_t) = Q(s_t, A_t) + \alpha \Big[ r_t + \gamma Q(s_{t+1}, A') - Q(s_t, A_t) \Big]$

Where:

- $\alpha$ – learning rate
- $\gamma$ – discount factor
- $r_t$ – reward at time $t$
- $s_{t+1}$ – next state
- $A'$ – best action in that state

The final dynamic key is:

$K = g(K_{password}^{DQN}, K_{biometric}^{DQN}, K_{token}^{DQN})$

This ensures **privacy, adaptability, and resilience** against attacks.

### Signatures, ZKPs, and Quantum Security

Once the key is established, devices can sign messages:

- **Signature** – $Sig = Sign(sk, D)$, proving origin without exposing sensitive information.
- **Verification** – $Verify(pk, Sig, D) \Rightarrow True/False$, enabling universal verification.

ZKP-based privacy layers ensure that signatures remain confidential while still being verifiable on-chain. Combined with **post-quantum cryptography (NTRU, Kyber)**, IoT architectures can maintain **long-term security** even in the age of quantum computing.

---

## 3. ZKP-Based Authentication and Verification for DePIN

While DePIN leverages blockchain for security and governance, it lacks mechanisms to establish trust in participating devices and their services. Traditional verification approaches face two challenges: **on-chain verification risks exposing confidential device attributes**, while **off-chain verification introduces undesirable trust assumptions**. As a result, DePIN struggles to ensure both data reliability and service quality. For example, many services require device-specific properties (e.g., CPU performance, bandwidth, sensor capabilities, geolocation) to be verified, but relying on off-chain data exposes the system to tampering risks.

**Zero-Knowledge Proofs (ZKPs)** provide a powerful solution: they enable devices to prove their identity and attributes without disclosing sensitive information. By integrating ZKPs into the device registration and authentication process, DePIN can achieve privacy-preserving and transparent identity management for IoT devices.

### ZKP-Enabled Device Registration Framework

A typical **ZKP-based device registration and authentication framework** operates as follows:

- **Attribute categories**: device identity, capability, configuration, and installation.
- **Verification checks**: equality, range, membership, and time-related checks.
- **Issuers**: manufacturers, regulators, service providers, and device owners, who issue **Verifiable Credentials (VCs)** proving the attributes.
- **System architecture**: layered structure (device, configuration, proof, and application layers).
- **Trust anchor**: blockchain-based **Verifiable Data Registry (VDR)** that stores credential status and supports decentralized device identity management.

This ensures IoT devices can prove:

- **Authenticity** — they are genuine and untampered devices.
- **Eligibility** — they satisfy service-specific requirements (e.g., hardware security thresholds, compliance constraints, or whitelist membership).

All of this is achieved **without revealing sensitive information**, thanks to ZKPs.

Applications include:

- **IoT/DePIN networks** — proving sensor nodes or wireless hotspots are genuine.
- **Supply chains** — ensuring only registered devices can upload logistics data.
- **Decentralized wireless networks** — preventing spoofed nodes.
- **Trusted computing** — proving compliance of hardware/firmware state without leaking internals.

### End-to-End Process

#### 1) **Attestation (Credential Issuance)**

- **Issuers** provide devices with **Verifiable Credentials (VCs)**, where each claim is cryptographically signed.
- A device’s **public key** becomes its core identifier for future on-chain verification.
- The VC is stored locally on the device, while its **credential status (CS)** is registered in the **VDR**.

#### 2) **Setup (System Initialization)**

- **Proof Specification (zkSpec)**: defines the verification logic, including:

  - Authenticity checks (issuer signature validation).
  - Conditional checks (range, equality, or membership proofs).

- **Key Generation**: zkSpec is compiled into an **executable constraint system (ECS)**. Running **KeyGen** produces proving key (pk) and verification key (vk).
- **Deployment**: zkSpec, pk, and CS references are stored in the VDR. The **verification key** and zkVPR (zkSpec + pk + CS reference) are embedded in a **Registration Contract** deployed on-chain.

#### 3) **Registration (Proof & Verification)**

- **Proving**: the device owner collects zkVPR and CS, compiles zkSpec with private inputs, and generates a ZK proof (zkVP) containing:

  - Device public key.
  - Auxiliary data.
  - Proof of correct computation (π).
  - Example checks include:

    - **Range check**: firmware version ≥ security threshold.
    - **Membership check**: device location in an approved region list.
    - **Equality check**: device type matches a required category.

- **Verification**: the on-chain registration contract validates zkVP. If successful, the device’s public key is added to the registry, ensuring only registered devices can interact with application contracts.

Different ZKP systems can be chosen depending on the use case: **Groth16** offers efficiency but relies on a trusted setup (suitable for short-term deployments), while **Marlin** provides stronger security assumptions but with higher performance costs. Long-term, DePIN may adopt **transparent proof systems** with both scalability and privacy guarantees.

---

## ICN and ZKP-Enhanced CP-ABE for IoT Security

The adoption of **Information-Centric Networking (ICN)** in the Internet of Things (IoT) remains in an early stage. ICN improves data availability through **distributed caching** and supports large-scale IoT data delivery. However, its data-object–centric model introduces new challenges for **authentication** compared with traditional host-to-host communication.

Lightweight authentication via **Zero-Knowledge Proofs (ZKPs)** offers a promising solution, enabling a secure and scalable **publish/subscribe model** tailored for IoT. In parallel, **Ciphertext-Policy Attribute-Based Encryption (CP-ABE)** allows data publishers to enforce fine-grained access control policies — for example, “only users with attributes A and B may decrypt.” Yet IoT devices face resource constraints in both computation and bandwidth. If every device must attempt decryption on every ciphertext (even when attributes do not satisfy the policy), significant overhead is wasted.

By integrating **ZKP into CP-ABE**, the system can verify attributes before decryption, ensuring only qualified users proceed, thereby conserving resources and enhancing efficiency.

### System Setup

The scheme builds on **bilinear pairings**:

$$
e: G_0 \times G_0 \to G_1
$$

Let $h = g^\beta$, $u = e(g,g)^\alpha$, where $\alpha, \beta \in \mathbb{Z}_p$ are randomly chosen.

- **Public key**:

  PK = { $G_0, g, h, u$ }

- **Master key**:

  MK = { $\alpha, \beta$ }

Thus, the **Setup phase** outputs the system’s public parameters $PK$ and master secret $MK$.

### Key Generation with ZK Evidence

For each user, a private key $SK$ is derived from their attribute set:

Y = { $y_1, y_2, ..., y_m$ }

Attributes may represent roles (e.g., _MachineOperator_, _SafetyManager_). To strengthen unpredictability, the scheme introduces randomness:

- $r \in \mathbb{Z}_p$: global randomizer (ensures key uniqueness).
- $r_j \in \mathbb{Z}_p$: per-attribute randomizer (enhances security).

The private key is constructed as:

```math
SK = \left\{ D = g^{\frac{\alpha + r}{\beta}}, \quad
\forall y_j \in Y : D_j = g^r \cdot H(y_j)^{r_j}, \quad D'_j = g^{r_j} \right\}
```

Here:

- $D$: core key component.
- $D_j$: attribute-specific component.
- $D'_j$: auxiliary component for each attribute.

To avoid exposing private keys, each user also generates **Zero-Knowledge Evidence (EV)**. The evidence is derived by hashing segments of $SK$:

$$
X = \Bigg(\sum_{i=1}^{t} Hash_{256}(SK)_i \Bigg)^2 = \sum_{i=1}^t x_i
$$

The **evidence set** is:

$$
EV = \{ X, n = p \cdot q \}
$$

This ensures private keys can be verified without direct disclosure.

<details><summary>Code</summary>

```Algorithm
Algorithm 1 Generate Key and Evidence
Require: 𝑌 = {𝑦1,𝑦2,...,𝑦𝑚} (weighted attributes),
𝑀𝐾 = {𝛼,𝛽} (master key)
Ensure: 𝑆𝐾 (private key), 𝐸𝑉 (evidence for 𝑆𝐾)
1: Select a random value 𝑟 from the finite field ℤ𝑝
2: Initialize 𝑆𝐾 = {}
3: for each attribute 𝑦𝑗 in 𝑌 do
4: Select a unique random value 𝑟𝑗 from ℤ𝑝
5: Compute 𝐷𝑗 = 𝑔𝑟 ⋅𝐻(𝑦𝑗)𝑟𝑗
6: Compute 𝐷′𝑗 = 𝑔𝑟𝑗
7: Add 𝐷𝑗 and 𝐷′𝑗 to 𝑆𝐾
8: end for
9: Compute 𝐷 = 𝑔(𝛼+𝑟)∕𝛽 and add to 𝑆𝐾
10: Choose large primes 𝑝 and 𝑞, set 𝑛 = 𝑝 ⋅𝑞
11: Select length 𝑡 for evidence 𝐸𝑉
12: Compute 𝑋 = |𝐻𝑎𝑠ℎ256(𝑆𝐾)[0,...,𝑡]|2
13: Formulate 𝐸𝑉 = {𝑋,𝑛 = 𝑝 ∗ 𝑞}
14: return 𝑆𝐾,𝐸𝑉
```

</details>

### Encryption with Access Control

Data providers encrypt messages under a **tree-structured access policy $T$**, where:

- Internal nodes = threshold gates.
- Leaves = attributes.

Encryption procedure:

- A random secret $s$ is chosen.
- $s$ is distributed across $T$ using **LSSS-like secret sharing**.
- Each leaf node receives a share bound to an attribute.

The ciphertext is:

$$
CT = \{ T, \; \bar{C} = M \cdot e(g,g)^{\alpha s}, \; C = h^s, \; \{C_l, C'_l\}_{l \in Leaves(T)} \}
$$

Where:

- $\bar{C}$: main encrypted message.
- $C$: validation component.
- $(C_l, C'_l)$: attribute-bound shares.

<details><summary>Code</summary>

```
Algorithm 2 Encrypt Data
Require: 𝑀 (plaintext), 𝐴 (access structure), 𝑃𝐾 =
{𝐺0,𝑔,ℎ,𝑢} (public key)
Ensure: 𝐶𝑇 (ciphertext)
1: Compute 𝑀meta = H(𝑀) using hash function 
2: Initialize access tree T based on 𝐴
3: Select a random secret 𝑠 from ℤ𝑝
4: Define polynomial 𝑞𝑅 at root 𝑅 with 𝑞𝑅(0) = 𝑠
5: for each node 𝑥 within the tree T do
6: if 𝑥 equals the root node 𝑅 then
7: Proceed to next node
8: else
9: Set 𝑞𝑥(0) equal to the value of 𝑞parent of 𝑥 evalu-
ated at the index of 𝑥
10: Randomly select 𝑑𝑥 points to fully establish the
polynomial 𝑞𝑥
11: end if
12: end for
13: Compute ̄𝐶 = 𝑀 ⋅𝑒(𝑔,𝑔)𝛼⋅𝑠 and 𝐶 = ℎ𝑠
14: for each leaf node 𝑙 in T do
15: Compute 𝐶𝑙 = 𝑔𝑞𝑙(0)
16: Compute 𝐶′
𝑙 = 𝐻(att(𝑙))𝑞𝑙(0)
17: end for
18: Assemble ciphertext 𝐶𝑇 = {T , ̄𝐶,𝐶,{𝐶𝑙,𝐶′𝑙}∀𝑙∈Leaves(T )}
19: return 𝐶𝑇
```

</details>

### Zero-Knowledge Identity Verification

To authenticate data requesters before decryption, the system employs the **Feige-Fiat-Shamir (FFS) protocol**:

- **Initialization (Prover)**:

  Initialize(EV) = { $r, a \mid r \in (0,n), \; a \equiv r^2 \pmod{n}$ }

- **Challenge (Verifier)**:
  Generate a random sequence:

  Challenge(EV) = { $e_1, e_2, ..., e_t$ }, $\quad e_t \in$ {0,1 }

- **Response (Prover)**:

  $ANS = r \cdot \prod_{i=1}^t y_i^{e_i} \pmod{n}$

- **Verification (Verifier)**:
  Compute:

  $\lambda = \prod_{i=1}^t EV.x_i^{e_i} \pmod{n}$

  Check condition:

  $ANS^2 \equiv a \cdot \lambda \pmod{n}$

If satisfied, the requester is authenticated.

<details><summary>Code</summary>

```Algorithm
Algorithm 3 Zero-Knowledge Proof Verification
Require: 𝑆𝐾 (secret key), 𝐸𝑉 (evidence)
Ensure: Boolean value indicating proof validity
1: Prover 𝑃 generates a random variable 𝑟 ∈ (0,𝑛)
2: Prover 𝑃 computes 𝑎 = 𝑓(𝑟,𝑆𝐾)
3: Initialize verification sequence 𝑒 by the Verifier 𝑉
4: 𝑉 issues a challenge based on 𝐸𝑉
5: for 𝑖 = 1 to 𝑡 do
6: Generate 𝑒𝑖 ∈ {0,1} randomly
7: end for
8: Prover 𝑃 responds with 𝐴𝑁𝑆 = 𝑟 ⋅∏𝑡
𝑖=1 𝑦𝑒𝑖
𝑖 mod 𝑛
9: Verifier 𝑉 checks the response 𝐴𝑁𝑆
10: Compute 𝜆 = ∏𝑡
𝑖=1 𝐸𝑉 .𝑥𝑒𝑖
𝑖 mod 𝑛
11: if 𝐴𝑁𝑆2 ≡ 𝑎 ⋅𝜆 mod 𝑛 then
12: return True
13: else
14: return False
15: end if
```

</details>

### Decryption

Decryption mirrors the encryption’s **tree-based structure**. Starting from the leaves, nodes are recursively resolved:

- **Leaf node**:

  $DecNode(CT,SK,x) = \frac{e(D_i, C_x)}{e(D'_i, C'_x)} = e(g,g)^{r \cdot q_x(0)}$

- **Internal node**:

  $F_x = \prod_{z \in S_x} F_z^{\Lambda(ind(x), S'_x)(0)} = e(g,g)^{r \gamma q_x(0)}$

- **Final decryption**:

  $M = \frac{\bar{C}}{e(C, D)/A} = \frac{\bar{C}}{e(h^s, g^{(\alpha+r)/\beta}) / e(g,g)^{rs}} = M$

Thus, only users whose attributes satisfy the policy tree $T$ can reconstruct $s$ and recover the message.

<details><summary>Code</summary>

```Algorithm 4 Decryption Process
Require: 𝐶𝑇 (Ciphertext), 𝑆𝐾 (Secret Key), 𝑃𝐾 (Public
Key)
Ensure: 𝑀𝑚𝑒𝑡𝑎 (Decrypted Metadata)
1: function DECNODE(𝐶𝑇,𝑆𝐾,𝑥)
2: if 𝑥 matches a leaf node then
3: 𝑖 ←𝑎𝑡𝑡𝑟𝑖𝑏𝑢𝑡𝑒(𝑥)
4: return 𝑒(𝐷𝑖,𝐶𝑥)
𝑒(𝐷′𝑖,𝐶′𝑥) ⊳
𝐷𝑖 = 𝑔𝑟 ⋅𝐻(𝑖)𝑟𝑖,𝐶𝑥 = ℎ𝑞𝑥(0),𝐷′𝑖 = 𝑔𝑟𝑖,𝐶′𝑥 = 𝐻(𝑖)𝑞𝑥(0)
5: else
6: Initialize 𝐹𝑥 ←1
7: for each child node 𝑧 of 𝑥 do
8: 𝐹𝑧 ←DECNODE(𝐶𝑇,𝑆𝐾,𝑧)
9: Update 𝐹𝑥 using 𝐹𝑧 and Lagrange interpola-
tion
10: end for
11: return 𝐹𝑥
12: end if
13: end function
14: T ←Extract tree structure from 𝐶𝑇
15: ̄𝐶,𝐶 ←Extract ciphertext components from 𝐶𝑇
16: 𝑅 ←Root of tree T
17: 𝑀𝑚𝑒𝑡𝑎 ←DECNODE(𝐶𝑇,𝑆𝐾,𝑅)
18: return 𝑀𝑚𝑒𝑡𝑎
```

</details>

---

[Depinscan](https://depinscan.io)
[Eclipse-Mosquitto](https://github.com/eclipse-mosquitto/mosquitto)
[Mbed-TLS](https://github.com/Mbed-TLS/mbedtls)
[VPR](https://w3c-ccg.github.io/vp-request-spec/)
[Trustops](https://github.com/trustops/awesome-trustops)
