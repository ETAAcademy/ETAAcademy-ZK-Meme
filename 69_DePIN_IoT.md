# ETAAcademy-ZKMeme: 69. DePIN & IoT

<table>
  <tr>
    <th>title</th>
    <th>tags</th>
  </tr>
  <tr>
    <td>69. DePIN & IoT</td>
    <td>
      <table>
        <tr>
          <th>zk-meme</th>
          <th>basic</th>
          <th>quick_read</th>
          <td>DePIN_IoT</td>
        </tr>
      </table>
    </td>
  </tr>
</table>

[Github](https://github.com/ETAAcademy)ï½œ[Twitter](https://twitter.com/ETAAcademy)ï½œ[ETA-ZK-Meme](https://github.com/ETAAcademy/ETAAcademy-ZK-Meme)

Authors: [Evta](https://twitter.com/pwhattie), looking forward to your joining

# Zero-Knowledge Proofs in Decentralized Physical Infrastructure Networks

DePIN, as a decentralized physical infrastructure network that integrates Web 3.0, IoT, ZK, AI, and blockchain technologies, achieves ecosystem collaboration through token incentive mechanisms across more than 300 projects and 21 million active devices, thereby supporting the autonomous management of both physical and digital resource networks.

To address security challenges such as IoT device vulnerabilities and limited processing capabilities, the system constructs decentralized security frameworks that integrate blockchain, zero-knowledge proofs, zero-trust architecture, and post-quantum cryptography, while implementing privacy protection and resistance against quantum attacks through techniques such as ring signatures, DPoS consensus, and DQN-based dynamic key selection.

For device trust establishment in DePIN, zero-knowledge proofâ€“based registration and authentication frameworks enable non-revealing verification of device attributes, relying on different types of issuers that provide verifiable credential (VC) credentials via a three-stage process of Attestation, Setup, and Registration.

Meanwhile, to address authentication challenges of ICN in IoT environments, complete workflows â€” including Setup for key generation, KeyGen for private key and evidence creation, encryption for generating access policy trees, ZKP protocols for authenticity verification, and recursive decryption for secret reconstruction â€” ultimately form an intelligent DePIN-IoT ecosystem that both protects privacy and ensures security.

---

## 1. DePIN: Decentralized Physical Infrastructure Networks

**DePIN (Decentralized Physical Infrastructure Networks)** represents the convergence of Web 3.0 and the Internet of Things (IoT), designed to address key challenges of centralized infrastructures in the digital eraâ€”such as data privacy leaks, service disruptions, and high scalability costs.

The concept has evolved over time: from IoTeXâ€™s proposal of _MachineFi_, to Latticeâ€™s suggestion of _TIPIN_, and finally, the community-driven adoption of the term _DePIN_ in a Messari Twitter poll in November 2022. Compared to traditional infrastructure networks, DePIN is characterized by four core principles:

- **Collective Ownership & Incentives** â€“ Tokenized rewards foster bottom-up self-organization, preventing monopolistic control.
- **Cost Efficiency** â€“ Market-driven economics and participant-maintained devices lower operating costs, while transparent governance reduces corruption.
- **Resilience & Security** â€“ Decentralization ensures fault tolerance, while blockchain guarantees data integrity and privacy.
- **Openness & Innovation** â€“ Reduced entry barriers allow new participants to challenge legacy incumbents and foster innovation.

### A Growing Ecosystem

By 2025, DePIN has matured into an ecosystem of over **300 projects and 21 million active devices**, enabling individuals and organizations to collectively operate wireless networks, energy grids, and transportation services. Through the integration of blockchain, cryptoeconomics, AI, and IoT autonomy, DePIN overcomes the limitations of traditional centralized automation systems and creates self-governing, trustless economic entities.

The **three-layer architecture** of DePIN provides the foundation for autonomous services:

- **Physical/Operational Layer** â€“ IoT devices (sensors, actuators, robots) handle data collection and real-world execution, secured by hardware integration to ensure data integrity and device authentication.
- **Intelligence & Verification Layer** â€“ AI/ML models process sensor data, enable real-time decision-making, and conduct off-chain verification, improving responsiveness and optimizing resource allocation.
- **Blockchain & Governance Layer** â€“ Decentralized ledgers record transactions, execute smart contracts, and provide immutable auditability and trustless coordination.

### Integration of AI, IoT, and Blockchain

Projects like **Helium** and **Filecoin** have demonstrated how token incentives can encourage participants to contribute physical resources to networks. By merging AI, blockchain, and IoT, DePIN enables:

- **Autonomous Decision-Making** â€“ AI analyzes real-time IoT data to optimize responses.
- **Secure Transactions** â€“ Blockchain ensures immutability and security in M2M (machine-to-machine) exchanges.
- **Programmable Economies** â€“ Smart contracts allow IoT devices to engage directly in economic activity, managing **Real and Digital World Assets (RDWAs)**.

AI enhances asset management by interpreting sensor data, performing predictive maintenance, and coordinating logistics (repairs, replacements, inspections). DePIN networks support autonomous operationsâ€”from vending machines and EV charging to AI-driven autonomous vehicles.

Crucially, DePIN networks exhibit **adaptive organization**, dynamically restructuring in response to environmental or resource changes to maintain efficiency and resilience.

### Security and Trust in a Trustless World

DePIN relies on **three security pillars** to operate safely in adversarial, decentralized environments:

- **Oracles** â€“ Bridging real-world data with on-chain smart contracts.
- **Zero-Knowledge Proofs (zkSTARKs)** â€“ Validating off-chain computations and sensor readings without revealing sensitive data, while reducing on-chain costs.
- **Trusted Execution Environments (TEEs)** â€“ Secure enclaves (e.g., Intel TDX) isolate critical computations and provide verifiable execution proofs.

Complementing these is **software verification** through DevSecOps, VeriDevOps, and **TrustOps** frameworks, which embed trust, validation, and security into the entire software lifecycle.

TrustOps introduces a **evidence-driven trust model**:

- Raw evidence (code changes, build logs) is cryptographically authenticated.
- Authenticated evidence becomes _verifiable evidence_ via consensus.
- Verifiable evidence triggers automated actions (e.g., access control, deployment permissions), generating new evidence in a continuous trust loop.

### Infrastructure Layers and Resource Networks

The DePIN infrastructure comprises:

- **Overlay Networks** â€“ Peer-to-peer topologies ensure efficient communication without centralized servers, supporting blockchain-based value exchange.
- **Underlay Networks** â€“ Core networks, wireless access points, and terminals manage physical data transmission.
- **Endpoints** â€“ Devices like sensors, servers, and accelerators form the operational backbone.

DePIN applications fall into **two major categories**:

- **Physical Resource Networks** â€“ Location-based IoT deployments such as energy monitoring, smart city infrastructure, environmental sensors, mobility tracking, healthcare monitoring, and decentralized wireless networks (5G, WiFi, LoRaWAN, Bluetooth).
- **Digital Resource Networks** â€“ Shared digital assets providing cost-efficient and accessible services:

  - **Bandwidth Networks** (VPNs, CDNs, decentralized browsers)
  - **Storage Networks** (distributed file systems, databases)
  - **Compute Networks** (general-purpose and specialized compute marketplaces)
  - **AI Networks** (ML models, AI frameworks, GPU marketplaces)

Together, these form a comprehensive DePIN ecosystem spanning physical and digital resources.

### Operational Mechanics

DePINâ€™s operation is powered by **deployers** (who provide devices such as sensors, servers, or GPUs) and **miners** (who validate blockchain transactions for rewards). Smart contracts manage device allocation, data authorization, identities, reputation, and governance.

Users interact via **DApps**, purchasing services that trigger smart contract execution. Confirmed transactions allocate resources, and service providers are compensated through token rewards. This mechanism ensures self-sustaining and transparent infrastructure management.

### Overcoming Scalability & Interoperability Challenges

As DePIN expands into **autonomous machine networks**, scalability and interoperability become critical. Key solutions include:

- **Layer-2 technologies** (state channels, sidechains, rollups) to boost throughput and reduce latency.
- **Cross-chain protocols** (atomic swaps, relay chains) to enable seamless coordination across blockchains, vital for industries like energy management and robotics.

By enabling both internal M2M communications and external integrations with verifiable blockchain-backed security, DePIN provides the foundation for large-scale deployment and cross-industry collaborationâ€”unlocking broad **socioeconomic impact**.

---

## 2. Internet of Things (IoT)

The **Internet of Things (IoT)**, first proposed at MIT in 1999, envisions the interconnection of trillions of physical objects (â€œthingsâ€) enabled by four technological pillars: RFID, sensors, smart technologies, and nanotechnology. IoT systems typically operate across **five stages**:

- **Data Collection** â€“ capturing information from diverse sensors and RFID tags.
- **Storage** â€“ retaining data in cloud-based data centers.
- **Intelligent Processing** â€“ real-time analysis in the cloud to provide smart services.
- **Data Transmission** â€“ ensuring continuous flow of information between stages.
- **Delivery** â€“ securely and accurately distributing results to target devices.

While this architecture enables large-scale interconnectivity, it also introduces **unprecedented security challenges**, with vulnerabilities at every layer.

### Trust Management Challenges

IoT trust management faces severe difficulties:

- **Physical Vulnerability** â€“ Devices often lack tamper-resistant casings, rely on low-cost CPUs without advanced protection, and expose interfaces (e.g., JTAG) that can be exploited.
- **Limited Processing Power** â€“ Many devices can only handle lightweight tokens, leaving them susceptible to brute-force attacks.
- **Weak Memory Protection** â€“ The absence of virtualization allows malicious code to access credentials of other processes, enabling insider attacks.

To address these risks, **dynamic trust management systems** are required, allowing compromised devices to be revoked while safeguarding credentials via **Hardware Security Modules (HSMs)**, **Trusted Platform Modules (TPMs)**, or software-based key vaults. At the network level, IoT systems must ensure:

- **Confidentiality & Integrity** (AES encryption, message authentication codes).
- **Authentication & Authorization** (e.g., a glucose monitor should only accept input from an insulin pump, not a blood pressure meter).
- **Availability** (resilience against DoS attacks).
- **Non-repudiation** (accountability for all actions).

### Toward a Secure IoT Framework

Traditional identity management and access control are insufficient for IoT, due to:

- **Centralization** â€“ single points of failure and weak auditability.
- **Privacy Risks** â€“ conventional authentication exposes sensitive user/device information.
- **Quantum Vulnerability** â€“ future quantum computing could break existing cryptography.

Thus, IoT security requires a **Decentralized + Privacy-Preserving + Quantum-Resistant** framework, built on:

- **Blockchain** â€“ immutable records for identity and access management, ensuring traceability and auditability.
- **Zero-Knowledge Proofs (ZKPs)** â€“ authentication and verification without disclosing sensitive data.
- **Zero-Trust Architecture (ZTA)** â€“ â€œnever trust, always verify,â€ minimizing insider threats by re-authenticating every request.
- **Post-Quantum Cryptography (PQC)** â€“ algorithms like NTRU and Kyber to ensure resilience against quantum attacks.
- **Hybrid Reinforcement-Lattice Key Generation** â€“ a cryptographic scheme combining lattice-based cryptography with reinforcement learning for secure and efficient key management.
- **Deep Q-Network Multi-Factor Secure Keys (DQN-MFSK)** â€“ dynamic selection of multi-factor keys (password, biometric, token) using deep reinforcement learning.

### Privacy and Consensus Mechanisms

To enhance privacy and scalability, IoT leverages advanced cryptographic and consensus techniques:

- **Ring Signatures** â€“ enable group-based anonymous authentication. A message signed with $S = \sigma(m, {PK_1, \dots, PK_n})$ can be verified as coming from someone within the group, but without revealing which member signed it. This preserves **device anonymity** in IoT transactions.

- **Delegated Proof of Stake (DPoS)** â€“ ensures blockchain efficiency and scalability by electing a small set of delegates through stakeholder voting. A delegate $i$ is chosen with probability $p_i = \frac{v_i}{\sum_j v_j}$, where $v_i$ is the number of votes received. This model reduces overhead and improves throughput, making it well-suited for **high-concurrency IoT environments**.

### Multi-Factor Authentication with Dynamic Key Selection

IoT systems increasingly rely on **multi-factor authentication (MFA)** combining:

- Password factor $K_{password}$
- Biometric factor $K_{biometric}$ (fingerprint, facial recognition)
- Token factor $K_{token}$ (hardware keys, OTPs)

The final authentication key is derived as:

$K_{auth} = H(K_{password} \, || \, K_{biometric} \, || \, K_{token})$

While robust, static concatenation is not always optimalâ€”depending on context, one factor may be more secure than others (e.g., biometrics in one case, hardware tokens in another).

To adapt, IoT integrates **Deep Q-Networks (DQN)**, enabling systems to dynamically select the most suitable factor combination in real time.

The Q-value update follows the Bellman equation:

$Q(s_t, A_t) = Q(s_t, A_t) + \alpha \Big[ r_t + \gamma Q(s_{t+1}, A') - Q(s_t, A_t) \Big]$

Where:

- $\alpha$ â€“ learning rate
- $\gamma$ â€“ discount factor
- $r_t$ â€“ reward at time $t$
- $s_{t+1}$ â€“ next state
- $A'$ â€“ best action in that state

The final dynamic key is:

$K = g(K_{password}^{DQN}, K_{biometric}^{DQN}, K_{token}^{DQN})$

This ensures **privacy, adaptability, and resilience** against attacks.

### Signatures, ZKPs, and Quantum Security

Once the key is established, devices can sign messages:

- **Signature** â€“ $Sig = Sign(sk, D)$, proving origin without exposing sensitive information.
- **Verification** â€“ $Verify(pk, Sig, D) \Rightarrow True/False$, enabling universal verification.

ZKP-based privacy layers ensure that signatures remain confidential while still being verifiable on-chain. Combined with **post-quantum cryptography (NTRU, Kyber)**, IoT architectures can maintain **long-term security** even in the age of quantum computing.

---

## 3. ZKP-Based Authentication and Verification for DePIN

While DePIN leverages blockchain for security and governance, it lacks mechanisms to establish trust in participating devices and their services. Traditional verification approaches face two challenges: **on-chain verification risks exposing confidential device attributes**, while **off-chain verification introduces undesirable trust assumptions**. As a result, DePIN struggles to ensure both data reliability and service quality. For example, many services require device-specific properties (e.g., CPU performance, bandwidth, sensor capabilities, geolocation) to be verified, but relying on off-chain data exposes the system to tampering risks.

**Zero-Knowledge Proofs (ZKPs)** provide a powerful solution: they enable devices to prove their identity and attributes without disclosing sensitive information. By integrating ZKPs into the device registration and authentication process, DePIN can achieve privacy-preserving and transparent identity management for IoT devices.

### ZKP-Enabled Device Registration Framework

A typical **ZKP-based device registration and authentication framework** operates as follows:

- **Attribute categories**: device identity, capability, configuration, and installation.
- **Verification checks**: equality, range, membership, and time-related checks.
- **Issuers**: manufacturers, regulators, service providers, and device owners, who issue **Verifiable Credentials (VCs)** proving the attributes.
- **System architecture**: layered structure (device, configuration, proof, and application layers).
- **Trust anchor**: blockchain-based **Verifiable Data Registry (VDR)** that stores credential status and supports decentralized device identity management.

This ensures IoT devices can prove:

- **Authenticity** â€” they are genuine and untampered devices.
- **Eligibility** â€” they satisfy service-specific requirements (e.g., hardware security thresholds, compliance constraints, or whitelist membership).

All of this is achieved **without revealing sensitive information**, thanks to ZKPs.

Applications include:

- **IoT/DePIN networks** â€” proving sensor nodes or wireless hotspots are genuine.
- **Supply chains** â€” ensuring only registered devices can upload logistics data.
- **Decentralized wireless networks** â€” preventing spoofed nodes.
- **Trusted computing** â€” proving compliance of hardware/firmware state without leaking internals.

### End-to-End Process

#### 1) **Attestation (Credential Issuance)**

- **Issuers** provide devices with **Verifiable Credentials (VCs)**, where each claim is cryptographically signed.
- A deviceâ€™s **public key** becomes its core identifier for future on-chain verification.
- The VC is stored locally on the device, while its **credential status (CS)** is registered in the **VDR**.

#### 2) **Setup (System Initialization)**

- **Proof Specification (zkSpec)**: defines the verification logic, including:

  - Authenticity checks (issuer signature validation).
  - Conditional checks (range, equality, or membership proofs).

- **Key Generation**: zkSpec is compiled into an **executable constraint system (ECS)**. Running **KeyGen** produces proving key (pk) and verification key (vk).
- **Deployment**: zkSpec, pk, and CS references are stored in the VDR. The **verification key** and zkVPR (zkSpec + pk + CS reference) are embedded in a **Registration Contract** deployed on-chain.

#### 3) **Registration (Proof & Verification)**

- **Proving**: the device owner collects zkVPR and CS, compiles zkSpec with private inputs, and generates a ZK proof (zkVP) containing:

  - Device public key.
  - Auxiliary data.
  - Proof of correct computation (Ï€).
  - Example checks include:

    - **Range check**: firmware version â‰¥ security threshold.
    - **Membership check**: device location in an approved region list.
    - **Equality check**: device type matches a required category.

- **Verification**: the on-chain registration contract validates zkVP. If successful, the deviceâ€™s public key is added to the registry, ensuring only registered devices can interact with application contracts.

Different ZKP systems can be chosen depending on the use case: **Groth16** offers efficiency but relies on a trusted setup (suitable for short-term deployments), while **Marlin** provides stronger security assumptions but with higher performance costs. Long-term, DePIN may adopt **transparent proof systems** with both scalability and privacy guarantees.

---

## ICN and ZKP-Enhanced CP-ABE for IoT Security

The adoption of **Information-Centric Networking (ICN)** in the Internet of Things (IoT) remains in an early stage. ICN improves data availability through **distributed caching** and supports large-scale IoT data delivery. However, its data-objectâ€“centric model introduces new challenges for **authentication** compared with traditional host-to-host communication.

Lightweight authentication via **Zero-Knowledge Proofs (ZKPs)** offers a promising solution, enabling a secure and scalable **publish/subscribe model** tailored for IoT. In parallel, **Ciphertext-Policy Attribute-Based Encryption (CP-ABE)** allows data publishers to enforce fine-grained access control policies â€” for example, â€œonly users with attributes A and B may decrypt.â€ Yet IoT devices face resource constraints in both computation and bandwidth. If every device must attempt decryption on every ciphertext (even when attributes do not satisfy the policy), significant overhead is wasted.

By integrating **ZKP into CP-ABE**, the system can verify attributes before decryption, ensuring only qualified users proceed, thereby conserving resources and enhancing efficiency.

### System Setup

The scheme builds on **bilinear pairings**:

$$
e: G_0 \times G_0 \to G_1
$$

Let $h = g^\beta$, $u = e(g,g)^\alpha$, where $\alpha, \beta \in \mathbb{Z}_p$ are randomly chosen.

- **Public key**:

  PK = { $G_0, g, h, u$ }

- **Master key**:

  MK = { $\alpha, \beta$ }

Thus, the **Setup phase** outputs the systemâ€™s public parameters $PK$ and master secret $MK$.

### Key Generation with ZK Evidence

For each user, a private key $SK$ is derived from their attribute set:

Y = { $y_1, y_2, ..., y_m$ }

Attributes may represent roles (e.g., _MachineOperator_, _SafetyManager_). To strengthen unpredictability, the scheme introduces randomness:

- $r \in \mathbb{Z}_p$: global randomizer (ensures key uniqueness).
- $r_j \in \mathbb{Z}_p$: per-attribute randomizer (enhances security).

The private key is constructed as:

```math
SK = \left\{ D = g^{\frac{\alpha + r}{\beta}}, \quad
\forall y_j \in Y : D_j = g^r \cdot H(y_j)^{r_j}, \quad D'_j = g^{r_j} \right\}
```

Here:

- $D$: core key component.
- $D_j$: attribute-specific component.
- $D'_j$: auxiliary component for each attribute.

To avoid exposing private keys, each user also generates **Zero-Knowledge Evidence (EV)**. The evidence is derived by hashing segments of $SK$:

$$
X = \Bigg(\sum_{i=1}^{t} Hash_{256}(SK)_i \Bigg)^2 = \sum_{i=1}^t x_i
$$

The **evidence set** is:

$$
EV = \{ X, n = p \cdot q \}
$$

This ensures private keys can be verified without direct disclosure.

<details><summary>Code</summary>

```Algorithm
Algorithm 1 Generate Key and Evidence
Require: ğ‘Œ = {ğ‘¦1,ğ‘¦2,...,ğ‘¦ğ‘š} (weighted attributes),
ğ‘€ğ¾ = {ğ›¼,ğ›½} (master key)
Ensure: ğ‘†ğ¾ (private key), ğ¸ğ‘‰ (evidence for ğ‘†ğ¾)
1: Select a random value ğ‘Ÿ from the finite field â„¤ğ‘
2: Initialize ğ‘†ğ¾ = {}
3: for each attribute ğ‘¦ğ‘— in ğ‘Œ do
4: Select a unique random value ğ‘Ÿğ‘— from â„¤ğ‘
5: Compute ğ·ğ‘— = ğ‘”ğ‘Ÿ â‹…ğ»(ğ‘¦ğ‘—)ğ‘Ÿğ‘—
6: Compute ğ·â€²ğ‘— = ğ‘”ğ‘Ÿğ‘—
7: Add ğ·ğ‘— and ğ·â€²ğ‘— to ğ‘†ğ¾
8: end for
9: Compute ğ· = ğ‘”(ğ›¼+ğ‘Ÿ)âˆ•ğ›½ and add to ğ‘†ğ¾
10: Choose large primes ğ‘ and ğ‘, set ğ‘› = ğ‘ â‹…ğ‘
11: Select length ğ‘¡ for evidence ğ¸ğ‘‰
12: Compute ğ‘‹ = |ğ»ğ‘ğ‘ â„256(ğ‘†ğ¾)[0,...,ğ‘¡]|2
13: Formulate ğ¸ğ‘‰ = {ğ‘‹,ğ‘› = ğ‘ âˆ— ğ‘}
14: return ğ‘†ğ¾,ğ¸ğ‘‰
```

</details>

### Encryption with Access Control

Data providers encrypt messages under a **tree-structured access policy $T$**, where:

- Internal nodes = threshold gates.
- Leaves = attributes.

Encryption procedure:

- A random secret $s$ is chosen.
- $s$ is distributed across $T$ using **LSSS-like secret sharing**.
- Each leaf node receives a share bound to an attribute.

The ciphertext is:

$$
CT = \{ T, \; \bar{C} = M \cdot e(g,g)^{\alpha s}, \; C = h^s, \; \{C_l, C'_l\}_{l \in Leaves(T)} \}
$$

Where:

- $\bar{C}$: main encrypted message.
- $C$: validation component.
- $(C_l, C'_l)$: attribute-bound shares.

<details><summary>Code</summary>

```
Algorithm 2 Encrypt Data
Require: ğ‘€ (plaintext), ğ´ (access structure), ğ‘ƒğ¾ =
{ğº0,ğ‘”,â„,ğ‘¢} (public key)
Ensure: ğ¶ğ‘‡ (ciphertext)
1: Compute ğ‘€meta = H(ğ‘€) using hash function îˆ´
2: Initialize access tree T based on ğ´
3: Select a random secret ğ‘  from â„¤ğ‘
4: Define polynomial ğ‘ğ‘… at root ğ‘… with ğ‘ğ‘…(0) = ğ‘ 
5: for each node ğ‘¥ within the tree T do
6: if ğ‘¥ equals the root node ğ‘… then
7: Proceed to next node
8: else
9: Set ğ‘ğ‘¥(0) equal to the value of ğ‘parent of ğ‘¥ evalu-
ated at the index of ğ‘¥
10: Randomly select ğ‘‘ğ‘¥ points to fully establish the
polynomial ğ‘ğ‘¥
11: end if
12: end for
13: Compute Ì„ğ¶ = ğ‘€ â‹…ğ‘’(ğ‘”,ğ‘”)ğ›¼â‹…ğ‘  and ğ¶ = â„ğ‘ 
14: for each leaf node ğ‘™ in T do
15: Compute ğ¶ğ‘™ = ğ‘”ğ‘ğ‘™(0)
16: Compute ğ¶â€²
ğ‘™ = ğ»(att(ğ‘™))ğ‘ğ‘™(0)
17: end for
18: Assemble ciphertext ğ¶ğ‘‡ = {T , Ì„ğ¶,ğ¶,{ğ¶ğ‘™,ğ¶â€²ğ‘™}âˆ€ğ‘™âˆˆLeaves(T )}
19: return ğ¶ğ‘‡
```

</details>

### Zero-Knowledge Identity Verification

To authenticate data requesters before decryption, the system employs the **Feige-Fiat-Shamir (FFS) protocol**:

- **Initialization (Prover)**:

  Initialize(EV) = { $r, a \mid r \in (0,n), \; a \equiv r^2 \pmod{n}$ }

- **Challenge (Verifier)**:
  Generate a random sequence:

  Challenge(EV) = { $e_1, e_2, ..., e_t$ }, $\quad e_t \in$ {0,1 }

- **Response (Prover)**:

  $ANS = r \cdot \prod_{i=1}^t y_i^{e_i} \pmod{n}$

- **Verification (Verifier)**:
  Compute:

  $\lambda = \prod_{i=1}^t EV.x_i^{e_i} \pmod{n}$

  Check condition:

  $ANS^2 \equiv a \cdot \lambda \pmod{n}$

If satisfied, the requester is authenticated.

<details><summary>Code</summary>

```Algorithm
Algorithm 3 Zero-Knowledge Proof Verification
Require: ğ‘†ğ¾ (secret key), ğ¸ğ‘‰ (evidence)
Ensure: Boolean value indicating proof validity
1: Prover ğ‘ƒ generates a random variable ğ‘Ÿ âˆˆ (0,ğ‘›)
2: Prover ğ‘ƒ computes ğ‘ = ğ‘“(ğ‘Ÿ,ğ‘†ğ¾)
3: Initialize verification sequence ğ‘’ by the Verifier ğ‘‰
4: ğ‘‰ issues a challenge based on ğ¸ğ‘‰
5: for ğ‘– = 1 to ğ‘¡ do
6: Generate ğ‘’ğ‘– âˆˆ {0,1} randomly
7: end for
8: Prover ğ‘ƒ responds with ğ´ğ‘ğ‘† = ğ‘Ÿ â‹…âˆğ‘¡
ğ‘–=1 ğ‘¦ğ‘’ğ‘–
ğ‘– mod ğ‘›
9: Verifier ğ‘‰ checks the response ğ´ğ‘ğ‘†
10: Compute ğœ† = âˆğ‘¡
ğ‘–=1 ğ¸ğ‘‰ .ğ‘¥ğ‘’ğ‘–
ğ‘– mod ğ‘›
11: if ğ´ğ‘ğ‘†2 â‰¡ ğ‘ â‹…ğœ† mod ğ‘› then
12: return True
13: else
14: return False
15: end if
```

</details>

### Decryption

Decryption mirrors the encryptionâ€™s **tree-based structure**. Starting from the leaves, nodes are recursively resolved:

- **Leaf node**:

  $DecNode(CT,SK,x) = \frac{e(D_i, C_x)}{e(D'_i, C'_x)} = e(g,g)^{r \cdot q_x(0)}$

- **Internal node**:

  $F_x = \prod_{z \in S_x} F_z^{\Lambda(ind(x), S'_x)(0)} = e(g,g)^{r \gamma q_x(0)}$

- **Final decryption**:

  $M = \frac{\bar{C}}{e(C, D)/A} = \frac{\bar{C}}{e(h^s, g^{(\alpha+r)/\beta}) / e(g,g)^{rs}} = M$

Thus, only users whose attributes satisfy the policy tree $T$ can reconstruct $s$ and recover the message.

<details><summary>Code</summary>

```Algorithm 4 Decryption Process
Require: ğ¶ğ‘‡ (Ciphertext), ğ‘†ğ¾ (Secret Key), ğ‘ƒğ¾ (Public
Key)
Ensure: ğ‘€ğ‘šğ‘’ğ‘¡ğ‘ (Decrypted Metadata)
1: function DECNODE(ğ¶ğ‘‡,ğ‘†ğ¾,ğ‘¥)
2: if ğ‘¥ matches a leaf node then
3: ğ‘– â†ğ‘ğ‘¡ğ‘¡ğ‘Ÿğ‘–ğ‘ğ‘¢ğ‘¡ğ‘’(ğ‘¥)
4: return ğ‘’(ğ·ğ‘–,ğ¶ğ‘¥)
ğ‘’(ğ·â€²ğ‘–,ğ¶â€²ğ‘¥) âŠ³
ğ·ğ‘– = ğ‘”ğ‘Ÿ â‹…ğ»(ğ‘–)ğ‘Ÿğ‘–,ğ¶ğ‘¥ = â„ğ‘ğ‘¥(0),ğ·â€²ğ‘– = ğ‘”ğ‘Ÿğ‘–,ğ¶â€²ğ‘¥ = ğ»(ğ‘–)ğ‘ğ‘¥(0)
5: else
6: Initialize ğ¹ğ‘¥ â†1
7: for each child node ğ‘§ of ğ‘¥ do
8: ğ¹ğ‘§ â†DECNODE(ğ¶ğ‘‡,ğ‘†ğ¾,ğ‘§)
9: Update ğ¹ğ‘¥ using ğ¹ğ‘§ and Lagrange interpola-
tion
10: end for
11: return ğ¹ğ‘¥
12: end if
13: end function
14: T â†Extract tree structure from ğ¶ğ‘‡
15: Ì„ğ¶,ğ¶ â†Extract ciphertext components from ğ¶ğ‘‡
16: ğ‘… â†Root of tree T
17: ğ‘€ğ‘šğ‘’ğ‘¡ğ‘ â†DECNODE(ğ¶ğ‘‡,ğ‘†ğ¾,ğ‘…)
18: return ğ‘€ğ‘šğ‘’ğ‘¡ğ‘
```

</details>

---

[Depinscan](https://depinscan.io)
[Eclipse-Mosquitto](https://github.com/eclipse-mosquitto/mosquitto)
[Mbed-TLS](https://github.com/Mbed-TLS/mbedtls)
[VPR](https://w3c-ccg.github.io/vp-request-spec/)
[Trustops](https://github.com/trustops/awesome-trustops)
